"""Base generator utilities shared across all generators."""

from __future__ import annotations

import re
from pathlib import Path
from typing import Any

from jinja2 import PackageLoader, select_autoescape
from jinja2.sandbox import SandboxedEnvironment
from ninja_core.schema.entity import EntitySchema

CODEGEN_HEADER = "# AUTO-GENERATED by ninja-codegen â€” DO NOT EDIT"

# Same regex used in ninja-core schema validators and ninja-agents safety.
_IDENTIFIER_RE = re.compile(r"^[A-Za-z][A-Za-z0-9_]{0,63}$")

_env: SandboxedEnvironment | None = None


def _safe_identifier(value: str) -> str:
    """Jinja2 filter that validates a value is a safe identifier.

    Raises ``ValueError`` if the value does not match the allowlist regex.
    This prevents template injection via entity/domain names.
    """
    s = str(value)
    if not _IDENTIFIER_RE.match(s):
        raise ValueError(
            f"Unsafe identifier in template: {s!r}. "
            "Must start with a letter, contain only alphanumeric "
            "characters and underscores, and be at most 64 characters."
        )
    return s


def get_template_env() -> SandboxedEnvironment:
    """Get the shared Jinja2 sandboxed template environment.

    Uses ``SandboxedEnvironment`` to prevent template-level code execution.
    Provides a ``safe_identifier`` filter for all name interpolations.
    """
    global _env
    if _env is None:
        _env = SandboxedEnvironment(
            loader=PackageLoader("ninja_codegen", "templates"),
            autoescape=select_autoescape([]),
            keep_trailing_newline=True,
            trim_blocks=True,
            lstrip_blocks=True,
        )
        _env.filters["repr"] = repr
        _env.filters["safe_identifier"] = _safe_identifier
    return _env


def validate_output_path(output_dir: Path, file_path: Path) -> Path:
    """Validate that a generated file path does not escape the output directory.

    Prevents path traversal attacks via entity/domain names containing ``..``
    or absolute path components.

    Args:
        output_dir: The base output directory for generated files.
        file_path: The proposed output file path.

    Returns:
        The resolved, validated file path.

    Raises:
        ValueError: If the path escapes the output directory.
    """
    resolved_output = output_dir.resolve()
    resolved_file = file_path.resolve()
    if not str(resolved_file).startswith(str(resolved_output)):
        raise ValueError(f"Path traversal detected: {file_path} escapes output directory {output_dir}")
    return resolved_file


def write_generated_file(path: Path, content: str) -> bool:
    """Write generated content to a file, returning True if the file changed.

    Skips writing if the content is identical (idempotent).
    """
    path.parent.mkdir(parents=True, exist_ok=True)
    if path.exists() and path.read_text() == content:
        return False
    path.write_text(content)
    return True


# Mapping from FieldType enum values (lowercase) to Python type annotations
FIELD_TYPE_MAP: dict[str, str] = {
    "string": "str",
    "text": "str",
    "integer": "int",
    "float": "float",
    "boolean": "bool",
    "datetime": "datetime",
    "date": "date",
    "uuid": "UUID",
    "json": "dict[str, Any]",
    "array": "list[Any]",
    "binary": "bytes",
    "enum": "str",
}

# Mapping from FieldType enum values (lowercase) to Strawberry/GraphQL type annotations
GQL_TYPE_MAP: dict[str, str] = {
    "string": "str",
    "text": "str",
    "integer": "int",
    "float": "float",
    "boolean": "bool",
    "datetime": "str",
    "date": "str",
    "uuid": "str",
    "json": "strawberry.scalars.JSON",
    "array": "list[str]",
    "binary": "str",
    "enum": "str",
}


def build_fields_meta(entity: EntitySchema) -> list[dict[str, Any]]:
    """Build pre-processed field metadata for templates.

    Resolves enum values to Python/GQL type strings so templates
    don't need to do dict lookups on enum objects.
    """
    fields: list[dict[str, Any]] = []
    for f in entity.fields:
        ft_value = f.field_type.value
        fields.append(
            {
                "name": f.name,
                "python_type": FIELD_TYPE_MAP.get(ft_value, "Any"),
                "gql_type": GQL_TYPE_MAP.get(ft_value, "str"),
                "field_type_value": ft_value,
                "nullable": f.nullable,
                "primary_key": f.primary_key,
                "unique": f.unique,
                "indexed": f.indexed,
                "default": f.default,
                "description": f.description,
                "constraints": f.constraints,
            }
        )
    return fields
