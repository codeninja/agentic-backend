"""Base generator utilities shared across all generators."""

from __future__ import annotations

import keyword
import re
from pathlib import Path
from typing import Any

from jinja2 import PackageLoader, select_autoescape
from jinja2.sandbox import SandboxedEnvironment
from ninja_core.schema.entity import EntitySchema

CODEGEN_HEADER = "# AUTO-GENERATED by ninja-codegen â€” DO NOT EDIT"

# Same regex used in ninja-core schema validators and ninja-agents safety.
_IDENTIFIER_RE = re.compile(r"^[A-Za-z][A-Za-z0-9_]{0,63}$")

_env: SandboxedEnvironment | None = None


def _safe_identifier(value: str) -> str:
    """Jinja2 filter that validates a value is a safe identifier.

    Raises ``ValueError`` if the value does not match the allowlist regex.
    This prevents template injection via entity/domain names.
    """
    s = str(value)
    if not _IDENTIFIER_RE.match(s):
        raise ValueError(
            f"Unsafe identifier in template: {s!r}. "
            "Must start with a letter, contain only alphanumeric "
            "characters and underscores, and be at most 64 characters."
        )
    if keyword.iskeyword(s):
        raise ValueError(f"Unsafe identifier in template: {s!r} is a Python reserved keyword.")
    return s


def get_template_env() -> SandboxedEnvironment:
    """Get the shared Jinja2 sandboxed template environment.

    Uses ``SandboxedEnvironment`` to prevent template-level code execution.
    Provides a ``safe_identifier`` filter for all name interpolations.
    """
    global _env
    if _env is None:
        _env = SandboxedEnvironment(
            loader=PackageLoader("ninja_codegen", "templates"),
            autoescape=select_autoescape([]),
            keep_trailing_newline=True,
            trim_blocks=True,
            lstrip_blocks=True,
        )
        _env.filters["repr"] = repr
        _env.filters["safe_identifier"] = _safe_identifier
    return _env


def sanitize_name(name: str, label: str = "name") -> str:
    """Sanitize an entity or domain name for safe use in file paths and imports.

    Provides defense-in-depth against path traversal even when upstream schema
    validation is in place.  Strips path components, then validates the result
    matches the safe identifier pattern.

    Args:
        name: The raw name to sanitize.
        label: Human-readable label for error messages (e.g. "entity name").

    Returns:
        The sanitized name, safe for use in file paths and Python identifiers.

    Raises:
        ValueError: If the name contains path traversal characters or is not
            a valid identifier after sanitization.
    """
    # Strip any directory components (defense against ``../`` injection)
    basename = Path(name).name

    # Reject if stripping changed the value (means path separators were present)
    if basename != name:
        raise ValueError(
            f"Path traversal detected in {label}: {name!r} "
            f"contains path separator characters"
        )

    # Reject path traversal sequences that survive Path.name (e.g. bare "..")
    if ".." in basename:
        raise ValueError(
            f"Path traversal detected in {label}: {name!r} "
            f"contains '..' sequence"
        )

    # Validate against the safe identifier pattern
    if not _IDENTIFIER_RE.match(basename):
        raise ValueError(
            f"Unsafe {label}: {name!r}. "
            "Must start with a letter, contain only alphanumeric "
            "characters and underscores, and be at most 64 characters."
        )

    # Reject Python keywords (e.g. "class", "import", "return") which would
    # produce syntactically invalid generated code.
    if keyword.iskeyword(basename):
        raise ValueError(
            f"Unsafe {label}: {name!r} is a Python reserved keyword."
        )

    return basename


def validate_output_path(output_dir: Path, file_path: Path) -> Path:
    """Validate that a generated file path does not escape the output directory.

    Prevents path traversal attacks via entity/domain names containing ``..``
    or absolute path components.

    Args:
        output_dir: The base output directory for generated files.
        file_path: The proposed output file path.

    Returns:
        The resolved, validated file path.

    Raises:
        ValueError: If the path escapes the output directory.
    """
    resolved_output = output_dir.resolve()
    resolved_file = file_path.resolve()
    if not resolved_file.is_relative_to(resolved_output):
        raise ValueError(
            f"Path traversal detected: {file_path} escapes output directory {output_dir}"
        )
    return resolved_file


def write_generated_file(path: Path, content: str) -> bool:
    """Write generated content to a file, returning True if the file changed.

    Skips writing if the content is identical (idempotent).
    """
    path.parent.mkdir(parents=True, exist_ok=True)
    if path.exists() and path.read_text() == content:
        return False
    path.write_text(content)
    return True


# Mapping from FieldType enum values (lowercase) to Python type annotations
FIELD_TYPE_MAP: dict[str, str] = {
    "string": "str",
    "text": "str",
    "integer": "int",
    "float": "float",
    "boolean": "bool",
    "datetime": "datetime",
    "date": "date",
    "uuid": "UUID",
    "json": "dict[str, Any]",
    "array": "list[Any]",
    "binary": "bytes",
    "enum": "str",
}

# Mapping from FieldType enum values (lowercase) to Strawberry/GraphQL type annotations
GQL_TYPE_MAP: dict[str, str] = {
    "string": "str",
    "text": "str",
    "integer": "int",
    "float": "float",
    "boolean": "bool",
    "datetime": "str",
    "date": "str",
    "uuid": "str",
    "json": "strawberry.scalars.JSON",
    "array": "list[str]",
    "binary": "str",
    "enum": "str",
}


def build_fields_meta(entity: EntitySchema) -> list[dict[str, Any]]:
    """Build pre-processed field metadata for templates.

    Resolves enum values to Python/GQL type strings so templates
    don't need to do dict lookups on enum objects.  Validates each
    field name as a safe Python identifier before it reaches templates.

    Raises:
        ValueError: If any field name is not a safe identifier.
    """
    fields: list[dict[str, Any]] = []
    for f in entity.fields:
        safe_field = sanitize_name(f.name, f"field name in entity {entity.name!r}")
        ft_value = f.field_type.value
        fields.append(
            {
                "name": safe_field,
                "python_type": FIELD_TYPE_MAP.get(ft_value, "Any"),
                "gql_type": GQL_TYPE_MAP.get(ft_value, "str"),
                "field_type_value": ft_value,
                "nullable": f.nullable,
                "primary_key": f.primary_key,
                "unique": f.unique,
                "indexed": f.indexed,
                "default": f.default,
                "description": f.description,
                "constraints": f.constraints,
            }
        )
    return fields
