{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"NinjaStack","text":"<p>Schema-first agentic backend framework. Point at a database, get a full agentic backend.</p> <p>NinjaStack auto-generates AI agents, GraphQL APIs, authentication, and UI from your data schema. Define once, generate everything.</p>"},{"location":"#what-is-ninjastack","title":"What is NinjaStack?","text":"<p>NinjaStack is a Python framework that transforms database schemas into fully functional agentic backends. Instead of hand-wiring agents, tools, permissions, and APIs, you define your data model once and the framework generates the entire stack.</p> <pre><code># Connect to your database\nninjastack introspect --db postgres://localhost/myapp\n\n# Generate everything\nninjastack sync\n\n# Run your agentic backend\nninjastack serve\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"Feature Description \ud83d\udd0d Database Introspection Auto-discover entities from SQL, MongoDB, Neo4j, or vector stores \ud83e\udd16 ADK Agent Generation Google ADK agents with scoped CRUD tools per entity \ud83e\uddec Agentic Schema Definition Typed, composable schema language \u2014 your single source of truth \ud83d\udd10 Auth &amp; RBAC Pluggable auth (OAuth2, JWT, API keys) with declarative permissions \ud83d\udcca GraphQL Generation Strawberry types, queries, mutations from schema \ud83d\udcac Conversational Setup Design your schema through natural dialogue with Gemini \ud83c\udfaf Tool Scoping Each agent only sees its own tools \u2014 no leaking \ud83d\ude80 K8s Deployment Helm charts generated automatically \ud83d\udd04 Polyglot Persistence Unified layer across SQL, NoSQL, graph, and vector DBs"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<pre><code>graph TD\n    U[User Request] --&gt; C[Coordinator Agent]\n    C --&gt; D1[Domain Agent: Catalog]\n    C --&gt; D2[Domain Agent: Commerce]\n    D1 --&gt; DA1[Data Agent: Book]\n    D1 --&gt; DA2[Data Agent: Review]\n    D2 --&gt; DA3[Data Agent: Customer]\n    D2 --&gt; DA4[Data Agent: Order]\n    DA1 --&gt; P[Unified Persistence]\n    DA2 --&gt; P\n    DA3 --&gt; P\n    DA4 --&gt; P\n    P --&gt; DB1[(SQL)]\n    P --&gt; DB2[(MongoDB)]\n    P --&gt; DB3[(Neo4j)]\n    P --&gt; DB4[(Vector Store)]</code></pre>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li> Getting Started \u2014 Install and run your first agentic backend</li> <li> Architecture \u2014 Agent hierarchy, ASD, codegen pipeline</li> <li> API Reference \u2014 Auto-generated from source docstrings</li> <li> Examples \u2014 Bookstore walkthrough covering every layer</li> </ul>"},{"location":"#tech-stack","title":"Tech Stack","text":"<ul> <li>Python 3.12+ with Pydantic v2</li> <li>Google ADK for agent execution</li> <li>FastAPI for the API server</li> <li>Strawberry for GraphQL</li> <li>LiteLLM for model-agnostic LLM access</li> <li>uv for package management</li> </ul>"},{"location":"architecture/","title":"Ninja Stack: Technical Blueprint &amp; Architecture","text":""},{"location":"architecture/#1-system-philosophy","title":"1. System Philosophy","text":"<p>The Ninja Stack is a Self-Assembling Agentic Framework. It treats the Agentic Schema Definition (ASD) as the \"DNA\" of the project. From this DNA, the system generates a library-first monorepo where every domain is managed by a specialized agent.</p>"},{"location":"architecture/#2-core-architecture","title":"2. Core Architecture","text":""},{"location":"architecture/#a-system-diagram-data-flow-composition","title":"A. System Diagram (Data Flow &amp; Composition)","text":"<pre><code>graph TD\n    subgraph \"Deployment Layer (Apps)\"\n        UI[Agentic Chat / CRUD UI]\n        API[FastAPI / GraphQL Shell]\n        AuthGate[Ninja Auth Gateway]\n        CLI[Ninja CLI]\n    end\n\n    subgraph \"Orchestration Layer (Agents)\"\n        Coordinator[Use Case Coordinator Agent]\n        DomainA[Domain Expert Agent: Logistics]\n        DomainB[Domain Expert Agent: Billing]\n    end\n\n    subgraph \"Logic &amp; Persistence Layer (Libraries)\"\n        LibAuth[libs/ninja-auth]\n        LibA[libs/domain-logistics]\n        LibB[libs/domain-billing]\n        Core[libs/ninja-core]\n    end\n\n    subgraph \"Universal Persistence (Polyglot)\"\n        SQL[(PostgreSQL)]\n        NoSQL[(MongoDB)]\n        Graph[(Neo4j / Graph-RAG)]\n        Vector[(Milvus / Chroma)]\n    end\n\n    %% Flow\n    UI --&gt; AuthGate\n    AuthGate --&gt; API\n    API --&gt; Coordinator\n    Coordinator --&gt; DomainA\n    Coordinator --&gt; DomainB\n\n    AuthGate --&gt; LibAuth\n    LibAuth --&gt; SQL\n\n    DomainA --&gt; LibA\n    DomainB --&gt; LibB\n\n    LibA --&gt; SQL\n    LibA --&gt; Graph\n    LibB --&gt; NoSQL\n    LibB --&gt; Vector\n\n    Core -.-&gt; |Informs| Coordinator\n    Core -.-&gt; |Informs| DomainA\n    Core -.-&gt; |Informs| DomainB</code></pre>"},{"location":"architecture/#b-data-flow-the-inverted-pyramid","title":"B. Data Flow: The \"Inverted Pyramid\"","text":"<p>Data enters through a thin application layer and flows down through increasingly granular, deterministic libraries.</p> <ol> <li>Request Layer (App Shell): FastAPI / GQL / CLI. No logic. Routes to a Use Case Coordinator Agent.</li> <li>Orchestration Layer (Coordinator Agents): High-level reasoning. Breaks requests into domain-specific tasks.</li> <li>Expert Layer (Domain Agents): Specialized ADK agents with domain-specific tools. They understand the \"Graph\" of their domain (e.g., how a <code>User</code> relates to <code>Billing</code>).</li> <li>Persistence Layer (Data Agents/Libraries): Pure Pydantic + SQL/NoSQL/Graph/Vector connectors. These are deterministic experts.</li> </ol>"},{"location":"architecture/#b-agent-interface-pattern","title":"B. Agent Interface Pattern","text":"<p>Every agent in the Ninja Stack follows the Tool-Scoped Interface: - Expertise: Defined by the ASD. - Tools: Auto-generated from the Persistence Layer libraries. - Communication: Uses Google ADK as the bus, targeting Gemini as the reasoning engine.</p>"},{"location":"architecture/#3-the-asd-agentic-schema-definition","title":"3. The ASD (Agentic Schema Definition)","text":"<p>The <code>.ninjastack/schema.json</code> is the source of truth. It defines: - Entities: (e.g., <code>Order</code>) Fields, Types, Embeddings. - Expert Domains: (e.g., <code>Logistics</code>) Which entities an agent \"owns.\" - Relationships:      - Hard: SQL Foreign Keys.     - Soft: Semantic/Vector links.     - Graph: Multi-hop relationship nodes.</p>"},{"location":"architecture/#4-implementation-plan-milestones","title":"4. Implementation Plan &amp; Milestones","text":""},{"location":"architecture/#milestone-1-the-foundation-the-dna-cli","title":"Milestone 1: The Foundation (The \"DNA\" &amp; CLI)","text":"<p>Objective: Build the core models and the CLI to manage them. - Ticket 1.1: Implement ASD Pydantic Models (<code>libs/ninja-core</code>). Define Entities, Domains, and Agents. - Ticket 1.2: Implement <code>ninjastack init</code> CLI. Spawns a Gemini-powered ADK agent to interview the user and write the initial <code>schema.json</code>. - Ticket 1.3: Implement <code>.ninjastack/</code> state management (Config, Environment, Secrets).</p>"},{"location":"architecture/#milestone-2-the-generator-the-sync-engine","title":"Milestone 2: The Generator (The \"Sync\" Engine)","text":"<p>Objective: Transform ASD into code. - Ticket 2.1: Implement the Polyglot Introspector. Connect to DBs and produce a draft ASD. - Ticket 2.2: Implement the Library Scaffolder. Generates <code>libs/domain-{name}</code> with Pydantic models and persistence logic. - Ticket 2.3: Implement the Agent Scaffolder. Generates ADK-compatible <code>agent.yaml</code> and tool definitions for each Domain Agent.</p>"},{"location":"architecture/#milestone-3-the-persistence-layer-polyglot-graph-rag","title":"Milestone 3: The Persistence Layer (Polyglot &amp; Graph-RAG)","text":"<p>Objective: Enable agents to actually \"see\" data. - Ticket 3.1: Implement Unified Persistence Wrapper (SQL/NoSQL support). - Ticket 3.2: Implement Vector/Semantic Search Integration as a first-class tool for all agents. - Ticket 3.3: Implement Graph-RAG Bootstrapper. Automatically populate Neo4j based on ASD relationships.</p>"},{"location":"architecture/#milestone-4-composition-apis-deployment","title":"Milestone 4: Composition, APIs &amp; Deployment","text":"<p>Objective: Generate the consumer-facing layers and deploy the stack. - Ticket 4.1: Implement GraphQL Layer Generator (<code>libs/ninja-gql</code>). Auto-generate Strawberry types, queries, mutations, and subscriptions from the ASD. \u2192 Plan 008 - Ticket 4.2: Implement UI Generator (<code>libs/ninja-ui</code>). CRUD data viewer and agentic chat interface. \u2192 Plan 009 - Ticket 4.3: Implement K8s/Helm Deployment Pipeline (<code>libs/ninja-deploy</code>). ASD-driven infrastructure provisioning and CI/CD generation. \u2192 Plan 010</p>"},{"location":"architecture/#milestone-5-the-ninja-auth-gateway","title":"Milestone 5: The Ninja Auth Gateway","text":"<p>Objective: Secure the stack with a pluggable identity layer. - Ticket 5.1: Implement <code>libs/ninja-auth</code> core. Define unified User/Session/Identity interfaces. - Ticket 5.2: Implement Auth Strategy Modules (OAuth2, Bearer/JWT, API Key, Identity/Registration). - Ticket 5.3: Implement <code>NinjaAuthGateway</code>. Middleware for policy enforcement and user context injection. \u2192 Plan 007</p>"},{"location":"architecture/#cross-cutting-plans","title":"Cross-Cutting Plans","text":"<ul> <li>Plan 006: Data Tolerance &amp; Boundary Layer (<code>libs/ninja-boundary</code>).</li> <li>Plan 011: LiteLLM &amp; Model Integration (<code>libs/ninja-models</code>).</li> <li>Plan 012: Monorepo Build System &amp; Library Testing Infrastructure.</li> <li>Plan 013: Agent Orchestration &amp; ADK Integration Patterns (<code>libs/ninja-agents</code>).</li> </ul>"},{"location":"architecture/#5-agent-at-every-level-internal-architecture","title":"5. Agent-at-Every-Level (Internal Architecture)","text":"<ul> <li>The Setup Agent: Expert in Ninja Stack architecture. Helps you build the project.</li> <li>The Domain Agents: Experts in their specific slice of the data. <ul> <li>Example: <code>BillingAgent</code> has tools: <code>get_invoice</code>, <code>process_refund</code>, <code>search_billing_docs_semantic</code>.</li> </ul> </li> <li>The Coordinator Agent: Expert in routing. <ul> <li>Example: \"My order is wrong\" -&gt; Routes to <code>OrderAgent</code> (to find it) + <code>SupportAgent</code> (to log ticket).</li> </ul> </li> </ul>"},{"location":"architecture/#6-execution-strategy","title":"6. Execution Strategy","text":"<ol> <li>Initialize GitHub Repo.</li> <li>Commit this Technical Blueprint to <code>docs/architecture.md</code>.</li> <li>Begin Milestone 1, Ticket 1.1 (Core Models).</li> </ol>"},{"location":"api/","title":"API Reference","text":"<p>Auto-generated documentation from source code docstrings.</p>"},{"location":"api/#packages","title":"Packages","text":""},{"location":"api/#core","title":"Core","text":"<ul> <li>Entity Schema \u2014 <code>ninja_core.schema.entity</code></li> <li>Domain Schema \u2014 <code>ninja_core.schema.domain</code></li> <li>Relationship Schema \u2014 <code>ninja_core.schema.relationship</code></li> <li>Agent Config \u2014 <code>ninja_core.schema.agent</code></li> <li>Project Schema \u2014 <code>ninja_core.schema.project</code></li> </ul>"},{"location":"api/#agents","title":"Agents","text":"<ul> <li>Base Agents \u2014 <code>ninja_agents.base</code> (DataAgent, DomainAgent, CoordinatorAgent)</li> <li>Tools \u2014 <code>ninja_agents.tools</code> (CRUD tool generation)</li> <li>Tracing \u2014 <code>ninja_agents.tracing</code> (execution tracing)</li> <li>Orchestrator \u2014 <code>ninja_agents.orchestrator</code></li> </ul>"},{"location":"api/#auth","title":"Auth","text":"<ul> <li>Gateway \u2014 <code>ninja_auth.gateway</code> (middleware)</li> <li>RBAC \u2014 <code>ninja_auth.rbac</code> (roles, permissions, enforcement)</li> <li>Context \u2014 <code>ninja_auth.context</code> (UserContext)</li> <li>Strategies \u2014 <code>ninja_auth.strategies</code> (OAuth2, JWT, API key, Identity)</li> </ul>"},{"location":"api/#code-generation","title":"Code Generation","text":"<ul> <li>Engine \u2014 <code>ninja_codegen.engine</code></li> <li>Generators \u2014 <code>ninja_codegen.generators</code> (models, agents, graphql)</li> </ul>"},{"location":"api/agents/base/","title":"Base Agents","text":""},{"location":"api/agents/base/#ninja_agents.base","title":"base","text":"<p>Base agent classes \u2014 DataAgent, DomainAgent, CoordinatorAgent.</p> <p>DataAgent extends ADK <code>BaseAgent</code> for deterministic CRUD (no LLM). DomainAgent and CoordinatorAgent wrap ADK <code>LlmAgent</code> with scoped sub-agents and tools, preserving the Ninja Stack delegation hierarchy.</p>"},{"location":"api/agents/base/#ninja_agents.base.DataAgent","title":"DataAgent","text":"<p>               Bases: <code>BaseAgent</code></p> <p>Deterministic agent that owns a single entity.</p> <p>Extends ADK <code>BaseAgent</code> \u2014 performs CRUD operations via its scoped tool set without LLM calls (unless reasoning_level is explicitly raised).</p>"},{"location":"api/agents/base/#ninja_agents.base.DataAgent.execute","title":"execute","text":"<pre><code>execute(\n    tool_name: str,\n    trace: TraceContext | None = None,\n    **kwargs: Any,\n) -&gt; Any\n</code></pre> <p>Execute a tool by name.  Raises <code>KeyError</code> if not in scope.</p> Source code in <code>libs/ninja-agents/src/ninja_agents/base.py</code> <pre><code>def execute(\n    self,\n    tool_name: str,\n    trace: TraceContext | None = None,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"Execute a tool by name.  Raises ``KeyError`` if not in scope.\"\"\"\n    tool = self._tool_map.get(tool_name)\n    if tool is None:\n        raise KeyError(f\"Tool '{tool_name}' not in scope for agent '{self.name}'. Available: {self.tool_names}\")\n    span = trace.start_span(self.name) if trace else None\n    try:\n        return invoke_tool(tool, span=span, **kwargs)\n    finally:\n        if trace:\n            trace.finish_span(self.name)\n</code></pre>"},{"location":"api/agents/base/#ninja_agents.base.DomainAgent","title":"DomainAgent","text":"<pre><code>DomainAgent(\n    domain: DomainSchema,\n    data_agents: list[DataAgent],\n    config: AgentConfig | None = None,\n)\n</code></pre> <p>LLM-powered agent that owns a domain (group of entities).</p> <p>Wraps an ADK <code>LlmAgent</code> whose <code>sub_agents</code> are the domain's <code>DataAgent</code> instances.  Provides convenience methods for synchronous delegation and execution that work without an LLM call (useful for testing and deterministic paths).</p> Source code in <code>libs/ninja-agents/src/ninja_agents/base.py</code> <pre><code>def __init__(\n    self,\n    domain: DomainSchema,\n    data_agents: list[DataAgent],\n    config: AgentConfig | None = None,\n) -&gt; None:\n    self.domain = domain\n    self.config = config or domain.agent_config\n    self.name = f\"domain_agent_{domain.name.lower()}\"\n    self._data_agents: dict[str, DataAgent] = {da.entity.name: da for da in data_agents}\n\n    model = _REASONING_MODEL.get(self.config.reasoning_level, _DEFAULT_MODEL)\n    self.agent = LlmAgent(\n        name=self.name,\n        model=model,\n        description=f\"Domain agent for {domain.name}\",\n        instruction=(\n            f\"You are the {domain.name} domain agent. Delegate CRUD operations to your DataAgent sub-agents.\"\n        ),\n        tools=[],\n        sub_agents=list(data_agents),\n    )\n</code></pre>"},{"location":"api/agents/base/#ninja_agents.base.DomainAgent.delegate","title":"delegate","text":"<pre><code>delegate(\n    entity_name: str,\n    tool_name: str,\n    trace: TraceContext | None = None,\n    **kwargs: Any,\n) -&gt; Any\n</code></pre> <p>Delegate a tool call to a DataAgent.  Raises <code>KeyError</code> if the entity is not in this domain.</p> Source code in <code>libs/ninja-agents/src/ninja_agents/base.py</code> <pre><code>def delegate(\n    self,\n    entity_name: str,\n    tool_name: str,\n    trace: TraceContext | None = None,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"Delegate a tool call to a DataAgent.  Raises ``KeyError`` if\n    the entity is not in this domain.\"\"\"\n    da = self._data_agents.get(entity_name)\n    if da is None:\n        raise KeyError(f\"Entity '{entity_name}' not in domain '{self.domain.name}'. Available: {self.entity_names}\")\n    if trace:\n        trace.start_span(self.name)\n    try:\n        return da.execute(tool_name, trace=trace, **kwargs)\n    finally:\n        if trace:\n            trace.finish_span(self.name)\n</code></pre>"},{"location":"api/agents/base/#ninja_agents.base.DomainAgent.execute","title":"execute","text":"<pre><code>execute(\n    request: str, trace: TraceContext | None = None\n) -&gt; dict[str, Any]\n</code></pre> <p>Process a domain-level request (stub \u2014 full impl uses LLM).</p> Source code in <code>libs/ninja-agents/src/ninja_agents/base.py</code> <pre><code>def execute(self, request: str, trace: TraceContext | None = None) -&gt; dict[str, Any]:\n    \"\"\"Process a domain-level request (stub \u2014 full impl uses LLM).\"\"\"\n    if trace:\n        trace.start_span(self.name)\n    try:\n        return {\n            \"agent\": self.name,\n            \"domain\": self.domain.name,\n            \"request\": request,\n            \"available_entities\": self.entity_names,\n            \"uses_llm\": self.uses_llm,\n        }\n    finally:\n        if trace:\n            trace.finish_span(self.name)\n</code></pre>"},{"location":"api/agents/base/#ninja_agents.base.CoordinatorAgent","title":"CoordinatorAgent","text":"<pre><code>CoordinatorAgent(\n    domain_agents: list[DomainAgent],\n    config: AgentConfig | None = None,\n)\n</code></pre> <p>Top-level routing agent that delegates to DomainAgents.</p> <p>Wraps an ADK <code>LlmAgent</code> whose <code>sub_agents</code> are the underlying <code>DomainAgent.agent</code> instances.  Uses LLM for intent classification and result synthesis.</p> Source code in <code>libs/ninja-agents/src/ninja_agents/base.py</code> <pre><code>def __init__(\n    self,\n    domain_agents: list[DomainAgent],\n    config: AgentConfig | None = None,\n) -&gt; None:\n    self.config = config or AgentConfig(reasoning_level=ReasoningLevel.HIGH)\n    self.name = \"coordinator\"\n    self._domain_agents: dict[str, DomainAgent] = {da.domain.name: da for da in domain_agents}\n\n    model = _REASONING_MODEL.get(self.config.reasoning_level, _DEFAULT_MODEL)\n    self.agent = LlmAgent(\n        name=self.name,\n        model=model,\n        description=\"Coordinator that routes requests across domains\",\n        instruction=(\n            \"You are the top-level coordinator. Classify the user's intent \"\n            \"and delegate to the appropriate domain agent.\"\n        ),\n        tools=[],\n        sub_agents=[da.agent for da in domain_agents],\n    )\n</code></pre>"},{"location":"api/agents/base/#ninja_agents.base.CoordinatorAgent.route","title":"route","text":"<pre><code>route(\n    request: str,\n    target_domains: list[str],\n    trace: TraceContext | None = None,\n) -&gt; dict[str, Any]\n</code></pre> <p>Route a request to specific domains and collect results.</p> <p>For parallel execution use <code>Orchestrator.fan_out()</code> instead.</p> Source code in <code>libs/ninja-agents/src/ninja_agents/base.py</code> <pre><code>def route(\n    self,\n    request: str,\n    target_domains: list[str],\n    trace: TraceContext | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Route a request to specific domains and collect results.\n\n    For parallel execution use ``Orchestrator.fan_out()`` instead.\n    \"\"\"\n    results: dict[str, Any] = {}\n    for domain_name in target_domains:\n        da = self._domain_agents.get(domain_name)\n        if da is None:\n            results[domain_name] = {\"error\": f\"Unknown domain: {domain_name}\"}\n            continue\n        results[domain_name] = da.execute(request, trace=trace)\n    return results\n</code></pre>"},{"location":"api/agents/base/#ninja_agents.base.create_domain_agent","title":"create_domain_agent","text":"<pre><code>create_domain_agent(\n    domain: DomainSchema, data_agents: list[DataAgent]\n) -&gt; LlmAgent\n</code></pre> <p>Factory: create a bare ADK LlmAgent for a domain.</p> Source code in <code>libs/ninja-agents/src/ninja_agents/base.py</code> <pre><code>def create_domain_agent(\n    domain: DomainSchema,\n    data_agents: list[DataAgent],\n) -&gt; LlmAgent:\n    \"\"\"Factory: create a bare ADK LlmAgent for a domain.\"\"\"\n    model = _REASONING_MODEL.get(domain.agent_config.reasoning_level, _DEFAULT_MODEL)\n    return LlmAgent(\n        name=f\"domain_agent_{domain.name.lower()}\",\n        model=model,\n        description=f\"Domain agent for {domain.name} \u2014 cross-entity reasoning\",\n        instruction=(f\"You are the {domain.name} domain agent. Delegate CRUD operations to your DataAgent sub-agents.\"),\n        tools=[],\n        sub_agents=list(data_agents),\n    )\n</code></pre>"},{"location":"api/agents/base/#ninja_agents.base.create_coordinator_agent","title":"create_coordinator_agent","text":"<pre><code>create_coordinator_agent(\n    domain_agents: list[DomainAgent],\n) -&gt; LlmAgent\n</code></pre> <p>Factory: create a bare ADK LlmAgent coordinator.</p> Source code in <code>libs/ninja-agents/src/ninja_agents/base.py</code> <pre><code>def create_coordinator_agent(\n    domain_agents: list[DomainAgent],\n) -&gt; LlmAgent:\n    \"\"\"Factory: create a bare ADK LlmAgent coordinator.\"\"\"\n    return LlmAgent(\n        name=\"coordinator\",\n        model=_DEFAULT_MODEL,\n        description=\"Coordinator that routes requests across domains\",\n        instruction=(\"Classify the user's intent and delegate to the appropriate domain agent.\"),\n        tools=[],\n        sub_agents=[da.agent for da in domain_agents],\n    )\n</code></pre>"},{"location":"api/agents/orchestrator/","title":"Orchestrator","text":""},{"location":"api/agents/orchestrator/#ninja_agents.orchestrator","title":"orchestrator","text":"<p>Parallel delegation \u2014 Coordinator fans out to DomainAgents concurrently.</p> <p>Uses ADK <code>ParallelAgent</code> for the fan-out topology while keeping a synchronous convenience wrapper for non-async callers.</p>"},{"location":"api/agents/orchestrator/#ninja_agents.orchestrator.Orchestrator","title":"Orchestrator","text":"<pre><code>Orchestrator(coordinator: CoordinatorAgent)\n</code></pre> <p>Orchestrates parallel fan-out from a CoordinatorAgent to multiple DomainAgents.</p> <p>Provides <code>build_parallel_agent()</code> to construct an ADK <code>ParallelAgent</code> for use within the ADK runtime, and <code>fan_out()</code> / <code>fan_out_sync()</code> for direct programmatic parallel execution.</p> Source code in <code>libs/ninja-agents/src/ninja_agents/orchestrator.py</code> <pre><code>def __init__(self, coordinator: CoordinatorAgent) -&gt; None:\n    self.coordinator = coordinator\n</code></pre>"},{"location":"api/agents/orchestrator/#ninja_agents.orchestrator.Orchestrator.build_parallel_agent","title":"build_parallel_agent","text":"<pre><code>build_parallel_agent(\n    target_domains: list[str] | None = None,\n) -&gt; ParallelAgent\n</code></pre> <p>Build an ADK ParallelAgent for fan-out execution.</p> <p>Creates fresh <code>LlmAgent</code> instances (ADK enforces single-parent, so the coordinator's own sub_agents cannot be reused here).</p> Source code in <code>libs/ninja-agents/src/ninja_agents/orchestrator.py</code> <pre><code>def build_parallel_agent(self, target_domains: list[str] | None = None) -&gt; ParallelAgent:\n    \"\"\"Build an ADK ParallelAgent for fan-out execution.\n\n    Creates fresh ``LlmAgent`` instances (ADK enforces single-parent,\n    so the coordinator's own sub_agents cannot be reused here).\n    \"\"\"\n    domains = target_domains or self.coordinator.domain_names\n    sub_agents: list[LlmAgent] = []\n    for d in domains:\n        da = self.coordinator.get_domain_agent(d)\n        if da is not None:\n            sub_agents.append(\n                LlmAgent(\n                    name=f\"{da.name}_parallel\",\n                    model=da.agent.model,\n                    description=da.agent.description,\n                    instruction=da.agent.instruction,\n                    tools=[],\n                    sub_agents=[],\n                )\n            )\n    return ParallelAgent(name=\"parallel_fan_out\", sub_agents=sub_agents)\n</code></pre>"},{"location":"api/agents/orchestrator/#ninja_agents.orchestrator.Orchestrator.fan_out","title":"fan_out  <code>async</code>","text":"<pre><code>fan_out(\n    request: str,\n    target_domains: list[str] | None = None,\n    trace: TraceContext | None = None,\n) -&gt; dict[str, Any]\n</code></pre> <p>Fan out request to multiple domains concurrently, collect results.</p> PARAMETER DESCRIPTION <code>request</code> <p>The user request to process.</p> <p> TYPE: <code>str</code> </p> <code>target_domains</code> <p>Domains to route to.  Defaults to all domains.</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>trace</code> <p>Optional trace context for observability.</p> <p> TYPE: <code>TraceContext | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Dict mapping domain name to its result.</p> Source code in <code>libs/ninja-agents/src/ninja_agents/orchestrator.py</code> <pre><code>async def fan_out(\n    self,\n    request: str,\n    target_domains: list[str] | None = None,\n    trace: TraceContext | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Fan out request to multiple domains concurrently, collect results.\n\n    Args:\n        request: The user request to process.\n        target_domains: Domains to route to.  Defaults to all domains.\n        trace: Optional trace context for observability.\n\n    Returns:\n        Dict mapping domain name to its result.\n    \"\"\"\n    domains = target_domains or self.coordinator.domain_names\n    if trace:\n        trace.start_span(self.coordinator.name)\n    try:\n        tasks = [_execute_domain(self.coordinator, d, request, trace) for d in domains]\n        results_list = await asyncio.gather(*tasks, return_exceptions=True)\n        results: dict[str, Any] = {}\n        for item in results_list:\n            if isinstance(item, Exception):\n                results[\"_error\"] = str(item)\n            else:\n                domain_name, result = item\n                results[domain_name] = result\n        return results\n    finally:\n        if trace:\n            trace.finish_span(self.coordinator.name)\n</code></pre>"},{"location":"api/agents/orchestrator/#ninja_agents.orchestrator.Orchestrator.fan_out_sync","title":"fan_out_sync","text":"<pre><code>fan_out_sync(\n    request: str,\n    target_domains: list[str] | None = None,\n    trace: TraceContext | None = None,\n) -&gt; dict[str, Any]\n</code></pre> <p>Synchronous wrapper around fan_out for non-async contexts.</p> Source code in <code>libs/ninja-agents/src/ninja_agents/orchestrator.py</code> <pre><code>def fan_out_sync(\n    self,\n    request: str,\n    target_domains: list[str] | None = None,\n    trace: TraceContext | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Synchronous wrapper around fan_out for non-async contexts.\"\"\"\n    return asyncio.run(self.fan_out(request, target_domains, trace))\n</code></pre>"},{"location":"api/agents/tools/","title":"Tools","text":""},{"location":"api/agents/tools/#ninja_agents.tools","title":"tools","text":"<p>Tool generation helpers \u2014 given an EntitySchema, produce plain-function CRUD tools.</p> <p>ADK auto-generates tool schemas from function name + docstring + type hints, so each tool is a simple callable (no wrapper dataclass needed).</p>"},{"location":"api/agents/tools/#ninja_agents.tools.generate_crud_tools","title":"generate_crud_tools","text":"<pre><code>generate_crud_tools(\n    entity: EntitySchema,\n) -&gt; list[Callable[..., Any]]\n</code></pre> <p>Generate CRUD + semantic search tool functions for an entity.</p> <p>Each returned function has <code>__name__</code> set to <code>&lt;entity&gt;_&lt;operation&gt;</code> and a docstring describing the operation \u2014 this is all ADK needs to build the tool schema automatically.</p> Source code in <code>libs/ninja-agents/src/ninja_agents/tools.py</code> <pre><code>def generate_crud_tools(entity: EntitySchema) -&gt; list[Callable[..., Any]]:\n    \"\"\"Generate CRUD + semantic search tool functions for an entity.\n\n    Each returned function has ``__name__`` set to ``&lt;entity&gt;_&lt;operation&gt;``\n    and a docstring describing the operation \u2014 this is all ADK needs to\n    build the tool schema automatically.\n    \"\"\"\n    tools: list[Callable[..., Any]] = []\n    for operation, desc_template in _CRUD_OPERATIONS:\n        description = desc_template.format(entity=entity.name)\n        tools.append(_make_tool(entity.name, operation, description))\n    return tools\n</code></pre>"},{"location":"api/agents/tools/#ninja_agents.tools.invoke_tool","title":"invoke_tool","text":"<pre><code>invoke_tool(\n    tool: Callable[..., Any],\n    span: AgentSpan | None = None,\n    **kwargs: Any,\n) -&gt; Any\n</code></pre> <p>Invoke a tool function, optionally recording the call in a trace span.</p> Source code in <code>libs/ninja-agents/src/ninja_agents/tools.py</code> <pre><code>def invoke_tool(\n    tool: Callable[..., Any],\n    span: AgentSpan | None = None,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"Invoke a tool function, optionally recording the call in a trace span.\"\"\"\n    start = time.monotonic()\n    error: str | None = None\n    success = True\n    try:\n        result = tool(**kwargs)\n    except Exception as exc:\n        error = str(exc)\n        success = False\n        raise\n    else:\n        return result\n    finally:\n        duration_ms = (time.monotonic() - start) * 1000\n        if span is not None:\n            span.record_tool_call(\n                tool_name=getattr(tool, \"__name__\", \"unknown\"),\n                input_summary=str(kwargs)[:200],\n                output_summary=\"\" if not success else str(result)[:200],  # type: ignore[possibly-undefined]\n                duration_ms=duration_ms,\n                success=success,\n                error=error,\n            )\n</code></pre>"},{"location":"api/agents/tracing/","title":"Tracing","text":""},{"location":"api/agents/tracing/#ninja_agents.tracing","title":"tracing","text":"<p>Observability \u2014 trace context with structured logging, timing, and cost attribution.</p> <p>Integrates with ADK events: call <code>TraceContext.record_adk_event()</code> to capture token usage from <code>Event.usage_metadata</code> emitted by the ADK runtime.</p>"},{"location":"api/agents/tracing/#ninja_agents.tracing.ToolCallRecord","title":"ToolCallRecord  <code>dataclass</code>","text":"<pre><code>ToolCallRecord(\n    tool_name: str,\n    agent_name: str,\n    input_summary: str,\n    output_summary: str,\n    duration_ms: float,\n    success: bool,\n    error: str | None = None,\n)\n</code></pre> <p>Record of a single tool invocation.</p>"},{"location":"api/agents/tracing/#ninja_agents.tracing.AgentSpan","title":"AgentSpan  <code>dataclass</code>","text":"<pre><code>AgentSpan(\n    agent_name: str,\n    start_time: float = monotonic(),\n    end_time: float | None = None,\n    input_tokens: int = 0,\n    output_tokens: int = 0,\n    tool_calls: list[ToolCallRecord] = list(),\n)\n</code></pre> <p>Timing and cost span for a single agent invocation.</p>"},{"location":"api/agents/tracing/#ninja_agents.tracing.TraceContext","title":"TraceContext","text":"<pre><code>TraceContext(trace_id: str | None = None)\n</code></pre> <p>Trace context that flows through all agent hops in a request.</p> Source code in <code>libs/ninja-agents/src/ninja_agents/tracing.py</code> <pre><code>def __init__(self, trace_id: str | None = None) -&gt; None:\n    self.trace_id = trace_id or uuid.uuid4().hex\n    self.spans: list[AgentSpan] = []\n    self._active_spans: dict[str, AgentSpan] = {}\n</code></pre>"},{"location":"api/agents/tracing/#ninja_agents.tracing.TraceContext.record_adk_event","title":"record_adk_event","text":"<pre><code>record_adk_event(event: Any) -&gt; None\n</code></pre> <p>Extract token counts from an ADK <code>Event</code> and attribute them.</p> <p>If the event has <code>usage_metadata</code> with <code>prompt_token_count</code> / <code>candidates_token_count</code>, the tokens are recorded on the active span for <code>event.author</code> (if one exists).</p> Source code in <code>libs/ninja-agents/src/ninja_agents/tracing.py</code> <pre><code>def record_adk_event(self, event: Any) -&gt; None:\n    \"\"\"Extract token counts from an ADK ``Event`` and attribute them.\n\n    If the event has ``usage_metadata`` with ``prompt_token_count`` /\n    ``candidates_token_count``, the tokens are recorded on the active\n    span for ``event.author`` (if one exists).\n    \"\"\"\n    author: str | None = getattr(event, \"author\", None)\n    usage = getattr(event, \"usage_metadata\", None)\n    if author and usage:\n        span = self._active_spans.get(author)\n        if span is None:\n            span = self.start_span(author)\n        input_tokens = getattr(usage, \"prompt_token_count\", 0) or 0\n        output_tokens = getattr(usage, \"candidates_token_count\", 0) or 0\n        if input_tokens or output_tokens:\n            span.record_tokens(input_tokens, output_tokens)\n</code></pre>"},{"location":"api/auth/context/","title":"Context","text":""},{"location":"api/auth/context/#ninja_auth.context","title":"context","text":"<p>User context model injected into agent request chain.</p>"},{"location":"api/auth/context/#ninja_auth.context.UserContext","title":"UserContext","text":"<p>               Bases: <code>BaseModel</code></p> <p>Authenticated user identity available throughout the request lifecycle.</p>"},{"location":"api/auth/gateway/","title":"Auth","text":""},{"location":"api/auth/gateway/#ninja_auth.gateway","title":"gateway","text":"<p>ASGI/FastAPI middleware that intercepts requests and delegates to auth strategies.</p>"},{"location":"api/auth/gateway/#ninja_auth.gateway.AuthGateway","title":"AuthGateway","text":"<pre><code>AuthGateway(app: Any, config: AuthConfig | None = None)\n</code></pre> <p>               Bases: <code>BaseHTTPMiddleware</code></p> <p>Starlette middleware that authenticates requests and injects UserContext into request state.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/gateway.py</code> <pre><code>def __init__(self, app: Any, config: AuthConfig | None = None) -&gt; None:\n    super().__init__(app)\n    self.config = config or AuthConfig()\n    self._bearer = BearerStrategy(self.config.bearer)\n    self._apikey = ApiKeyStrategy(self.config.api_key)\n    self._rbac = RBACPolicy(self.config.rbac)\n</code></pre>"},{"location":"api/auth/gateway/#ninja_auth.gateway.AuthGateway.dispatch","title":"dispatch  <code>async</code>","text":"<pre><code>dispatch(\n    request: Request, call_next: RequestResponseEndpoint\n) -&gt; Response\n</code></pre> <p>Authenticate the request and inject user context.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/gateway.py</code> <pre><code>async def dispatch(self, request: Request, call_next: RequestResponseEndpoint) -&gt; Response:\n    \"\"\"Authenticate the request and inject user context.\"\"\"\n    # Allow public paths through without auth\n    if self._is_public_path(request.url.path):\n        request.state.user_context = ANONYMOUS_USER\n        set_user_context(ANONYMOUS_USER)\n        return await call_next(request)\n\n    # Try each strategy in order\n    user_ctx = await self._try_authenticate(request)\n\n    if user_ctx is None:\n        return JSONResponse(\n            status_code=401,\n            content={\"detail\": \"Authentication required\"},\n        )\n\n    # Enrich user context with RBAC-resolved permissions\n    user_ctx = self._enrich_permissions(user_ctx)\n\n    # Inject user context into request state and contextvar for agent tools\n    request.state.user_context = user_ctx\n    set_user_context(user_ctx)\n    return await call_next(request)\n</code></pre>"},{"location":"api/auth/gateway/#ninja_auth.gateway.get_user_context","title":"get_user_context","text":"<pre><code>get_user_context(request: Request) -&gt; UserContext\n</code></pre> <p>FastAPI dependency to extract the authenticated user context from request state.</p> Usage <p>@app.get(\"/me\") async def me(user: UserContext = Depends(get_user_context)):     return user</p> Source code in <code>libs/ninja-auth/src/ninja_auth/gateway.py</code> <pre><code>def get_user_context(request: Request) -&gt; UserContext:\n    \"\"\"FastAPI dependency to extract the authenticated user context from request state.\n\n    Usage:\n        @app.get(\"/me\")\n        async def me(user: UserContext = Depends(get_user_context)):\n            return user\n    \"\"\"\n    ctx: UserContext | None = getattr(request.state, USER_CONTEXT_KEY, None)\n    if ctx is None:\n        return ANONYMOUS_USER\n    return ctx\n</code></pre>"},{"location":"api/auth/rbac/","title":"Rbac","text":""},{"location":"api/auth/rbac/#ninja_auth.rbac","title":"rbac","text":"<p>Role-based access control: roles, permissions, and enforcement.</p> <p>Permission format: <code>action:scope</code> where scope is a domain name or <code>domain.entity</code> pair.  The wildcard <code>*</code> matches everything.</p> <p>Examples:</p> <ul> <li><code>read:Orders</code>        \u2014 read any entity in the Orders domain</li> <li><code>write:Billing.Invoice</code> \u2014 write the Invoice entity in Billing</li> <li><code>delete:*</code>           \u2014 delete anything</li> <li><code>*:*</code>                \u2014 superuser (all actions, all scopes)</li> </ul> Built-in roles <ul> <li>admin  \u2014 <code>*:*</code></li> <li>editor \u2014 <code>read:*</code>, <code>write:*</code></li> <li>viewer \u2014 <code>read:*</code></li> </ul>"},{"location":"api/auth/rbac/#ninja_auth.rbac.Action","title":"Action","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Permission actions.</p>"},{"location":"api/auth/rbac/#ninja_auth.rbac.RoleDefinition","title":"RoleDefinition","text":"<p>               Bases: <code>BaseModel</code></p> <p>A named role with a list of permission strings.</p>"},{"location":"api/auth/rbac/#ninja_auth.rbac.RBACConfig","title":"RBACConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Declarative RBAC configuration (lives under <code>rbac</code> in auth.json).</p>"},{"location":"api/auth/rbac/#ninja_auth.rbac.RBACPolicy","title":"RBACPolicy","text":"<pre><code>RBACPolicy(config: RBACConfig | None = None)\n</code></pre> <p>Resolves roles to permissions and checks access.</p> <p>Merges built-in roles with any custom roles from config.  Custom roles with the same name as a built-in role override the built-in.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/rbac.py</code> <pre><code>def __init__(self, config: RBACConfig | None = None) -&gt; None:\n    self.config = config or RBACConfig()\n    self._role_permissions: dict[str, list[str]] = {}\n    self._build_role_map()\n</code></pre>"},{"location":"api/auth/rbac/#ninja_auth.rbac.RBACPolicy.roles","title":"roles","text":"<pre><code>roles() -&gt; list[str]\n</code></pre> <p>Return all known role names.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/rbac.py</code> <pre><code>def roles(self) -&gt; list[str]:\n    \"\"\"Return all known role names.\"\"\"\n    return list(self._role_permissions.keys())\n</code></pre>"},{"location":"api/auth/rbac/#ninja_auth.rbac.RBACPolicy.permissions_for_roles","title":"permissions_for_roles","text":"<pre><code>permissions_for_roles(roles: list[str]) -&gt; list[str]\n</code></pre> <p>Return the union of permissions granted by roles.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/rbac.py</code> <pre><code>def permissions_for_roles(self, roles: list[str]) -&gt; list[str]:\n    \"\"\"Return the union of permissions granted by *roles*.\"\"\"\n    seen: set[str] = set()\n    result: list[str] = []\n    for role in roles:\n        for perm in self._role_permissions.get(role, []):\n            if perm not in seen:\n                seen.add(perm)\n                result.append(perm)\n    return result\n</code></pre>"},{"location":"api/auth/rbac/#ninja_auth.rbac.RBACPolicy.is_allowed","title":"is_allowed","text":"<pre><code>is_allowed(\n    permissions: list[str],\n    action: str,\n    domain: str,\n    entity: str | None = None,\n) -&gt; bool\n</code></pre> <p>Check whether permissions grant action on domain (optionally entity).</p> Source code in <code>libs/ninja-auth/src/ninja_auth/rbac.py</code> <pre><code>def is_allowed(self, permissions: list[str], action: str, domain: str, entity: str | None = None) -&gt; bool:\n    \"\"\"Check whether *permissions* grant *action* on *domain* (optionally *entity*).\"\"\"\n    scope = f\"{domain}.{entity}\" if entity else domain\n    required = f\"{action}:{scope}\"\n    return any(permission_matches(grant, required) for grant in permissions)\n</code></pre>"},{"location":"api/auth/rbac/#ninja_auth.rbac.RBACPolicy.check","title":"check","text":"<pre><code>check(\n    permissions: list[str],\n    action: str,\n    domain: str,\n    entity: str | None = None,\n) -&gt; None\n</code></pre> <p>Like :meth:<code>is_allowed</code> but raises :class:<code>PermissionError</code> on denial.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/rbac.py</code> <pre><code>def check(self, permissions: list[str], action: str, domain: str, entity: str | None = None) -&gt; None:\n    \"\"\"Like :meth:`is_allowed` but raises :class:`PermissionError` on denial.\"\"\"\n    if not self.is_allowed(permissions, action, domain, entity):\n        scope = f\"{domain}.{entity}\" if entity else domain\n        raise PermissionError(f\"Permission denied: {action}:{scope}\")\n</code></pre>"},{"location":"api/auth/rbac/#ninja_auth.rbac.permission_matches","title":"permission_matches","text":"<pre><code>permission_matches(grant: str, required: str) -&gt; bool\n</code></pre> <p>Return True if grant satisfies required.</p> Wildcards <ul> <li><code>*</code> in the action position matches any action.</li> <li><code>*</code> in the scope position matches any scope.</li> <li><code>DomainName</code> in grant scope matches <code>DomainName.AnyEntity</code>.</li> </ul> Source code in <code>libs/ninja-auth/src/ninja_auth/rbac.py</code> <pre><code>def permission_matches(grant: str, required: str) -&gt; bool:\n    \"\"\"Return True if *grant* satisfies *required*.\n\n    Wildcards:\n        - ``*`` in the action position matches any action.\n        - ``*`` in the scope position matches any scope.\n        - ``DomainName`` in grant scope matches ``DomainName.AnyEntity``.\n    \"\"\"\n    g_action, g_scope = _parse_permission(grant)\n    r_action, r_scope = _parse_permission(required)\n\n    if not g_action or not r_action:\n        return False\n\n    # Action match\n    if g_action != \"*\" and g_action != r_action:\n        return False\n\n    # Scope match\n    if g_scope == \"*\":\n        return True\n    if g_scope == r_scope:\n        return True\n    # Domain-level grant covers domain.entity\n    if \".\" not in g_scope and r_scope.startswith(f\"{g_scope}.\"):\n        return True\n\n    return False\n</code></pre>"},{"location":"api/auth/rbac/#ninja_auth.rbac.require_domain_permission","title":"require_domain_permission","text":"<pre><code>require_domain_permission(\n    action: str,\n    domain: str,\n    entity: str | None = None,\n    *,\n    policy: RBACPolicy | None = None,\n) -&gt; None\n</code></pre> <p>Raise :class:<code>PermissionError</code> if the current user lacks the permission.</p> <p>Imports <code>current_user_context</code> lazily to avoid circular imports.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/rbac.py</code> <pre><code>def require_domain_permission(\n    action: str,\n    domain: str,\n    entity: str | None = None,\n    *,\n    policy: RBACPolicy | None = None,\n) -&gt; None:\n    \"\"\"Raise :class:`PermissionError` if the current user lacks the permission.\n\n    Imports ``current_user_context`` lazily to avoid circular imports.\n    \"\"\"\n    from ninja_auth.agent_context import current_user_context\n\n    ctx = current_user_context()\n    if not ctx.is_authenticated:\n        raise PermissionError(\"Authenticated user context required\")\n\n    _policy = policy or RBACPolicy()\n    _policy.check(ctx.permissions, action, domain, entity)\n</code></pre>"},{"location":"api/auth/strategies/","title":"Auth Strategies","text":""},{"location":"api/auth/strategies/#oauth2","title":"OAuth2","text":""},{"location":"api/auth/strategies/#ninja_auth.strategies.oauth2","title":"oauth2","text":"<p>OAuth2 strategy with support for Google, GitHub, and custom providers.</p>"},{"location":"api/auth/strategies/#ninja_auth.strategies.oauth2.OAuth2Strategy","title":"OAuth2Strategy","text":"<pre><code>OAuth2Strategy(\n    provider_name: str, config: OAuth2ProviderConfig\n)\n</code></pre> <p>Handles OAuth2 authorization code flow for external identity providers.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/strategies/oauth2.py</code> <pre><code>def __init__(self, provider_name: str, config: OAuth2ProviderConfig) -&gt; None:\n    self.provider_name = provider_name\n    self.config = config\n</code></pre>"},{"location":"api/auth/strategies/#ninja_auth.strategies.oauth2.OAuth2Strategy.get_authorization_url","title":"get_authorization_url","text":"<pre><code>get_authorization_url(state: str = '') -&gt; str\n</code></pre> <p>Build the URL to redirect the user to for OAuth2 authorization.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/strategies/oauth2.py</code> <pre><code>def get_authorization_url(self, state: str = \"\") -&gt; str:\n    \"\"\"Build the URL to redirect the user to for OAuth2 authorization.\"\"\"\n    params: dict[str, str] = {\n        \"client_id\": self.config.client_id,\n        \"redirect_uri\": self.config.redirect_uri,\n        \"response_type\": \"code\",\n        \"scope\": \" \".join(self.config.scopes),\n    }\n    if state:\n        params[\"state\"] = state\n    return f\"{self.config.authorize_url}?{urlencode(params)}\"\n</code></pre>"},{"location":"api/auth/strategies/#ninja_auth.strategies.oauth2.OAuth2Strategy.exchange_code","title":"exchange_code  <code>async</code>","text":"<pre><code>exchange_code(code: str) -&gt; dict[str, Any]\n</code></pre> <p>Exchange an authorization code for tokens.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/strategies/oauth2.py</code> <pre><code>async def exchange_code(self, code: str) -&gt; dict[str, Any]:\n    \"\"\"Exchange an authorization code for tokens.\"\"\"\n    async with httpx.AsyncClient() as client:\n        headers = {\"Accept\": \"application/json\"}\n        resp = await client.post(\n            self.config.token_url,\n            data={\n                \"grant_type\": \"authorization_code\",\n                \"client_id\": self.config.client_id,\n                \"client_secret\": self.config.client_secret,\n                \"code\": code,\n                \"redirect_uri\": self.config.redirect_uri,\n            },\n            headers=headers,\n        )\n        resp.raise_for_status()\n        return resp.json()\n</code></pre>"},{"location":"api/auth/strategies/#ninja_auth.strategies.oauth2.OAuth2Strategy.get_userinfo","title":"get_userinfo  <code>async</code>","text":"<pre><code>get_userinfo(access_token: str) -&gt; dict[str, Any]\n</code></pre> <p>Fetch user profile from the provider's userinfo endpoint.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/strategies/oauth2.py</code> <pre><code>async def get_userinfo(self, access_token: str) -&gt; dict[str, Any]:\n    \"\"\"Fetch user profile from the provider's userinfo endpoint.\"\"\"\n    async with httpx.AsyncClient() as client:\n        resp = await client.get(\n            self.config.userinfo_url,\n            headers={\"Authorization\": f\"Bearer {access_token}\"},\n        )\n        resp.raise_for_status()\n        return resp.json()\n</code></pre>"},{"location":"api/auth/strategies/#ninja_auth.strategies.oauth2.OAuth2Strategy.authenticate_with_code","title":"authenticate_with_code  <code>async</code>","text":"<pre><code>authenticate_with_code(code: str) -&gt; UserContext\n</code></pre> <p>Full OAuth2 flow: exchange code -&gt; fetch userinfo -&gt; return context.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/strategies/oauth2.py</code> <pre><code>async def authenticate_with_code(self, code: str) -&gt; UserContext:\n    \"\"\"Full OAuth2 flow: exchange code -&gt; fetch userinfo -&gt; return context.\"\"\"\n    tokens = await self.exchange_code(code)\n    access_token = tokens.get(\"access_token\", \"\")\n    userinfo = await self.get_userinfo(access_token)\n\n    # Normalize across providers\n    user_id = str(userinfo.get(\"sub\") or userinfo.get(\"id\", \"\"))\n    email = userinfo.get(\"email\")\n\n    return UserContext(\n        user_id=user_id,\n        email=email,\n        roles=[],\n        provider=f\"oauth2:{self.provider_name}\",\n        metadata={\"userinfo\": userinfo, \"access_token\": access_token},\n    )\n</code></pre>"},{"location":"api/auth/strategies/#bearer-jwt","title":"Bearer (JWT)","text":""},{"location":"api/auth/strategies/#ninja_auth.strategies.bearer","title":"bearer","text":"<p>JWT bearer token validation strategy.</p>"},{"location":"api/auth/strategies/#ninja_auth.strategies.bearer.BearerStrategy","title":"BearerStrategy","text":"<pre><code>BearerStrategy(config: BearerConfig)\n</code></pre> <p>Validates JWT bearer tokens and extracts user context.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/strategies/bearer.py</code> <pre><code>def __init__(self, config: BearerConfig) -&gt; None:\n    self.config = config\n</code></pre>"},{"location":"api/auth/strategies/#ninja_auth.strategies.bearer.BearerStrategy.authenticate","title":"authenticate  <code>async</code>","text":"<pre><code>authenticate(request: Request) -&gt; UserContext | None\n</code></pre> <p>Extract and validate a JWT from the Authorization header.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/strategies/bearer.py</code> <pre><code>async def authenticate(self, request: Request) -&gt; UserContext | None:\n    \"\"\"Extract and validate a JWT from the Authorization header.\"\"\"\n    auth_header = request.headers.get(\"authorization\", \"\")\n    if not auth_header.startswith(\"Bearer \"):\n        return None\n\n    token = auth_header[7:]\n    return self.validate_token(token)\n</code></pre>"},{"location":"api/auth/strategies/#ninja_auth.strategies.bearer.BearerStrategy.validate_token","title":"validate_token","text":"<pre><code>validate_token(token: str) -&gt; UserContext | None\n</code></pre> <p>Decode and validate a JWT, returning UserContext on success.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/strategies/bearer.py</code> <pre><code>def validate_token(self, token: str) -&gt; UserContext | None:\n    \"\"\"Decode and validate a JWT, returning UserContext on success.\"\"\"\n    try:\n        decode_opts: dict[str, Any] = {\n            \"algorithms\": self._get_algorithms(),\n        }\n        if self.config.issuer:\n            decode_opts[\"issuer\"] = self.config.issuer\n        if self.config.audience:\n            decode_opts[\"audience\"] = self.config.audience\n\n        payload = jwt.decode(\n            token,\n            self._get_signing_key(),\n            **decode_opts,\n        )\n\n        return UserContext(\n            user_id=payload.get(\"sub\", \"\"),\n            email=payload.get(\"email\"),\n            roles=payload.get(\"roles\", []),\n            permissions=payload.get(\"permissions\", []),\n            provider=\"bearer\",\n            metadata={\"claims\": payload},\n        )\n    except jwt.PyJWTError:\n        return None\n</code></pre>"},{"location":"api/auth/strategies/#api-key","title":"API Key","text":""},{"location":"api/auth/strategies/#ninja_auth.strategies.apikey","title":"apikey","text":"<p>API key validation strategy for service-to-service auth.</p>"},{"location":"api/auth/strategies/#ninja_auth.strategies.apikey.ApiKeyStrategy","title":"ApiKeyStrategy","text":"<pre><code>ApiKeyStrategy(config: ApiKeyConfig)\n</code></pre> <p>Validates API keys from a configured header against known keys.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/strategies/apikey.py</code> <pre><code>def __init__(self, config: ApiKeyConfig) -&gt; None:\n    self.config = config\n</code></pre>"},{"location":"api/auth/strategies/#ninja_auth.strategies.apikey.ApiKeyStrategy.authenticate","title":"authenticate  <code>async</code>","text":"<pre><code>authenticate(request: Request) -&gt; UserContext | None\n</code></pre> <p>Check the request header for a valid API key.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/strategies/apikey.py</code> <pre><code>async def authenticate(self, request: Request) -&gt; UserContext | None:\n    \"\"\"Check the request header for a valid API key.\"\"\"\n    api_key = request.headers.get(self.config.header_name.lower(), \"\")\n    if not api_key:\n        # Also check query param as fallback\n        api_key = request.query_params.get(\"api_key\", \"\")\n    if not api_key:\n        return None\n\n    return self.validate_key(api_key)\n</code></pre>"},{"location":"api/auth/strategies/#ninja_auth.strategies.apikey.ApiKeyStrategy.validate_key","title":"validate_key","text":"<pre><code>validate_key(api_key: str) -&gt; UserContext | None\n</code></pre> <p>Validate an API key against configured keys using constant-time comparison.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/strategies/apikey.py</code> <pre><code>def validate_key(self, api_key: str) -&gt; UserContext | None:\n    \"\"\"Validate an API key against configured keys using constant-time comparison.\"\"\"\n    for name, known_key in self.config.keys.items():\n        if hmac.compare_digest(\n            hashlib.sha256(api_key.encode()).hexdigest(),\n            hashlib.sha256(known_key.encode()).hexdigest(),\n        ):\n            return UserContext(\n                user_id=f\"apikey:{name}\",\n                roles=[\"service\"],\n                provider=\"apikey\",\n                metadata={\"key_name\": name},\n            )\n    return None\n</code></pre>"},{"location":"api/auth/strategies/#built-in-identity","title":"Built-in Identity","text":""},{"location":"api/auth/strategies/#ninja_auth.strategies.identity","title":"identity","text":"<p>Built-in identity strategy: user registration, login, password hashing.</p>"},{"location":"api/auth/strategies/#ninja_auth.strategies.identity.IdentityStrategy","title":"IdentityStrategy","text":"<pre><code>IdentityStrategy(config: IdentityConfig)\n</code></pre> <p>Manages local user accounts with password hashing and JWT session tokens.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/strategies/identity.py</code> <pre><code>def __init__(self, config: IdentityConfig) -&gt; None:\n    self.config = config\n    # In-memory store; production would use ninja-persistence\n    self._users: dict[str, dict[str, Any]] = {}\n</code></pre>"},{"location":"api/auth/strategies/#ninja_auth.strategies.identity.IdentityStrategy.hash_password","title":"hash_password","text":"<pre><code>hash_password(password: str) -&gt; str\n</code></pre> <p>Hash a plaintext password using bcrypt.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/strategies/identity.py</code> <pre><code>def hash_password(self, password: str) -&gt; str:\n    \"\"\"Hash a plaintext password using bcrypt.\"\"\"\n    return bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode()\n</code></pre>"},{"location":"api/auth/strategies/#ninja_auth.strategies.identity.IdentityStrategy.verify_password","title":"verify_password","text":"<pre><code>verify_password(plain: str, hashed: str) -&gt; bool\n</code></pre> <p>Verify a password against its bcrypt hash.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/strategies/identity.py</code> <pre><code>def verify_password(self, plain: str, hashed: str) -&gt; bool:\n    \"\"\"Verify a password against its bcrypt hash.\"\"\"\n    return bcrypt.checkpw(plain.encode(), hashed.encode())\n</code></pre>"},{"location":"api/auth/strategies/#ninja_auth.strategies.identity.IdentityStrategy.register","title":"register","text":"<pre><code>register(\n    email: str,\n    password: str,\n    roles: list[str] | None = None,\n) -&gt; UserContext\n</code></pre> <p>Register a new user account.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/strategies/identity.py</code> <pre><code>def register(self, email: str, password: str, roles: list[str] | None = None) -&gt; UserContext:\n    \"\"\"Register a new user account.\"\"\"\n    if email in self._users:\n        raise ValueError(f\"User already exists: {email}\")\n\n    user_id = secrets.token_hex(16)\n    self._users[email] = {\n        \"user_id\": user_id,\n        \"email\": email,\n        \"password_hash\": self.hash_password(password),\n        \"roles\": roles or [],\n        \"created_at\": datetime.now(timezone.utc).isoformat(),\n    }\n\n    return UserContext(\n        user_id=user_id,\n        email=email,\n        roles=roles or [],\n        provider=\"identity\",\n    )\n</code></pre>"},{"location":"api/auth/strategies/#ninja_auth.strategies.identity.IdentityStrategy.login","title":"login","text":"<pre><code>login(email: str, password: str) -&gt; UserContext | None\n</code></pre> <p>Authenticate a user by email and password.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/strategies/identity.py</code> <pre><code>def login(self, email: str, password: str) -&gt; UserContext | None:\n    \"\"\"Authenticate a user by email and password.\"\"\"\n    user = self._users.get(email)\n    if not user:\n        return None\n    if not self.verify_password(password, user[\"password_hash\"]):\n        return None\n\n    return UserContext(\n        user_id=user[\"user_id\"],\n        email=user[\"email\"],\n        roles=user.get(\"roles\", []),\n        provider=\"identity\",\n    )\n</code></pre>"},{"location":"api/auth/strategies/#ninja_auth.strategies.identity.IdentityStrategy.issue_token","title":"issue_token","text":"<pre><code>issue_token(user_ctx: UserContext) -&gt; str\n</code></pre> <p>Issue a JWT session token for an authenticated user.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/strategies/identity.py</code> <pre><code>def issue_token(self, user_ctx: UserContext) -&gt; str:\n    \"\"\"Issue a JWT session token for an authenticated user.\"\"\"\n    now = datetime.now(timezone.utc)\n    payload = {\n        \"sub\": user_ctx.user_id,\n        \"email\": user_ctx.email,\n        \"roles\": user_ctx.roles,\n        \"iat\": now,\n        \"exp\": now + timedelta(minutes=self.config.token_expiry_minutes),\n    }\n    return jwt.encode(payload, self.config.token_secret, algorithm=\"HS256\")\n</code></pre>"},{"location":"api/auth/strategies/#ninja_auth.strategies.identity.IdentityStrategy.validate_token","title":"validate_token","text":"<pre><code>validate_token(token: str) -&gt; UserContext | None\n</code></pre> <p>Validate a session token and return user context.</p> Source code in <code>libs/ninja-auth/src/ninja_auth/strategies/identity.py</code> <pre><code>def validate_token(self, token: str) -&gt; UserContext | None:\n    \"\"\"Validate a session token and return user context.\"\"\"\n    try:\n        payload = jwt.decode(token, self.config.token_secret, algorithms=[\"HS256\"])\n        return UserContext(\n            user_id=payload[\"sub\"],\n            email=payload.get(\"email\"),\n            roles=payload.get(\"roles\", []),\n            provider=\"identity\",\n        )\n    except jwt.PyJWTError:\n        return None\n</code></pre>"},{"location":"api/codegen/engine/","title":"Code Generation","text":""},{"location":"api/codegen/engine/#ninja_codegen.engine","title":"engine","text":"<p>Sync engine \u2014 orchestrates the full code generation pipeline.</p> <p>Reads the ASD from .ninjastack/schema.json, detects changes via the differ, runs the appropriate generators, and writes output into the project tree.</p>"},{"location":"api/codegen/engine/#ninja_codegen.engine.SyncResult","title":"SyncResult  <code>dataclass</code>","text":"<pre><code>SyncResult(\n    generated_files: list[Path] = list(),\n    diff: ASDDiff | None = None,\n    skipped: bool = False,\n)\n</code></pre> <p>Result of a sync operation.</p>"},{"location":"api/codegen/engine/#ninja_codegen.engine.sync","title":"sync","text":"<pre><code>sync(\n    root: Path | None = None,\n    output_dir: Path | None = None,\n    force: bool = False,\n) -&gt; SyncResult\n</code></pre> <p>Run the full sync pipeline.</p> PARAMETER DESCRIPTION <code>root</code> <p>Project root containing .ninjastack/. Defaults to cwd.</p> <p> TYPE: <code>Path | None</code> DEFAULT: <code>None</code> </p> <code>output_dir</code> <p>Where to write generated code. Defaults to root.</p> <p> TYPE: <code>Path | None</code> DEFAULT: <code>None</code> </p> <code>force</code> <p>If True, skip change detection and regenerate everything.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>SyncResult</code> <p>SyncResult with list of generated files and diff info.</p> Source code in <code>libs/ninja-codegen/src/ninja_codegen/engine.py</code> <pre><code>def sync(\n    root: Path | None = None,\n    output_dir: Path | None = None,\n    force: bool = False,\n) -&gt; SyncResult:\n    \"\"\"Run the full sync pipeline.\n\n    Args:\n        root: Project root containing .ninjastack/. Defaults to cwd.\n        output_dir: Where to write generated code. Defaults to root.\n        force: If True, skip change detection and regenerate everything.\n\n    Returns:\n        SyncResult with list of generated files and diff info.\n    \"\"\"\n    root = root or Path(\".\")\n    output_dir = output_dir or root\n\n    schema = load_schema(root / \".ninjastack\" / \"schema.json\")\n    return sync_schema(schema, root=root, output_dir=output_dir, force=force)\n</code></pre>"},{"location":"api/codegen/engine/#ninja_codegen.engine.sync_schema","title":"sync_schema","text":"<pre><code>sync_schema(\n    schema: AgenticSchema,\n    root: Path | None = None,\n    output_dir: Path | None = None,\n    force: bool = False,\n) -&gt; SyncResult\n</code></pre> <p>Run the sync pipeline from an in-memory AgenticSchema.</p> PARAMETER DESCRIPTION <code>schema</code> <p>The ASD to generate from.</p> <p> TYPE: <code>AgenticSchema</code> </p> <code>root</code> <p>Project root for snapshot storage. Defaults to cwd.</p> <p> TYPE: <code>Path | None</code> DEFAULT: <code>None</code> </p> <code>output_dir</code> <p>Where to write generated code. Defaults to root.</p> <p> TYPE: <code>Path | None</code> DEFAULT: <code>None</code> </p> <code>force</code> <p>If True, skip change detection and regenerate everything.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>SyncResult</code> <p>SyncResult with list of generated files and diff info.</p> Source code in <code>libs/ninja-codegen/src/ninja_codegen/engine.py</code> <pre><code>def sync_schema(\n    schema: AgenticSchema,\n    root: Path | None = None,\n    output_dir: Path | None = None,\n    force: bool = False,\n) -&gt; SyncResult:\n    \"\"\"Run the sync pipeline from an in-memory AgenticSchema.\n\n    Args:\n        schema: The ASD to generate from.\n        root: Project root for snapshot storage. Defaults to cwd.\n        output_dir: Where to write generated code. Defaults to root.\n        force: If True, skip change detection and regenerate everything.\n\n    Returns:\n        SyncResult with list of generated files and diff info.\n    \"\"\"\n    root = root or Path(\".\")\n    output_dir = output_dir or root\n    snapshot_dir = root / \".ninjastack\"\n\n    # Change detection\n    diff = compute_diff(schema, snapshot_dir)\n\n    if not force and not diff.has_changes:\n        return SyncResult(skipped=True, diff=diff)\n\n    generated: list[Path] = []\n\n    # Determine what to generate\n    if force or diff.is_full_sync:\n        entities_to_gen = schema.entities\n        domains_to_gen = schema.domains\n    else:\n        entity_names = set(diff.changed_entities)\n        domain_names = set(diff.changed_domains)\n        entities_to_gen = [e for e in schema.entities if e.name in entity_names]\n        domains_to_gen = [d for d in schema.domains if d.name in domain_names]\n\n    # Run generators\n    if entities_to_gen:\n        generated.extend(generate_models(entities_to_gen, output_dir))\n        generated.extend(generate_graphql(entities_to_gen, output_dir))\n\n    if entities_to_gen or domains_to_gen:\n        generated.extend(generate_agents(entities_to_gen, domains_to_gen, output_dir))\n\n    if diff.project_changed or diff.is_full_sync or force:\n        app_path = generate_app_shell(schema.project_name, output_dir)\n        generated.append(app_path)\n\n    # Save snapshot after successful generation\n    save_snapshot(schema, snapshot_dir)\n\n    return SyncResult(generated_files=generated, diff=diff)\n</code></pre>"},{"location":"api/codegen/generators/","title":"Code Generators","text":""},{"location":"api/codegen/generators/#models-generator","title":"Models Generator","text":""},{"location":"api/codegen/generators/#ninja_codegen.generators.models","title":"models","text":"<p>Generate Pydantic models from EntitySchema definitions.</p>"},{"location":"api/codegen/generators/#ninja_codegen.generators.models.generate_model","title":"generate_model","text":"<pre><code>generate_model(\n    entity: EntitySchema, output_dir: Path\n) -&gt; Path\n</code></pre> <p>Generate a Pydantic model file for a single entity.</p> PARAMETER DESCRIPTION <code>entity</code> <p>The entity schema to generate from.</p> <p> TYPE: <code>EntitySchema</code> </p> <code>output_dir</code> <p>Directory to write the generated file into.</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>Path</code> <p>Path to the generated file.</p> Source code in <code>libs/ninja-codegen/src/ninja_codegen/generators/models.py</code> <pre><code>def generate_model(entity: EntitySchema, output_dir: Path) -&gt; Path:\n    \"\"\"Generate a Pydantic model file for a single entity.\n\n    Args:\n        entity: The entity schema to generate from.\n        output_dir: Directory to write the generated file into.\n\n    Returns:\n        Path to the generated file.\n    \"\"\"\n    env = get_template_env()\n    template = env.get_template(\"model.py.j2\")\n\n    content = template.render(\n        entity=entity,\n        fields_meta=build_fields_meta(entity),\n        has_uuid=_has_field_type(entity, \"uuid\"),\n        has_datetime=_has_field_type(entity, \"datetime\"),\n        has_date=_has_field_type(entity, \"date\"),\n        has_constraints=any(f.constraints for f in entity.fields),\n    )\n\n    file_path = output_dir / f\"{entity.name.lower()}.py\"\n    write_generated_file(file_path, content)\n    return file_path\n</code></pre>"},{"location":"api/codegen/generators/#ninja_codegen.generators.models.generate_models","title":"generate_models","text":"<pre><code>generate_models(\n    entities: list[EntitySchema], output_dir: Path\n) -&gt; list[Path]\n</code></pre> <p>Generate Pydantic models for all entities.</p> PARAMETER DESCRIPTION <code>entities</code> <p>List of entity schemas.</p> <p> TYPE: <code>list[EntitySchema]</code> </p> <code>output_dir</code> <p>Base directory for generated model files.</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>list[Path]</code> <p>List of paths to generated files.</p> Source code in <code>libs/ninja-codegen/src/ninja_codegen/generators/models.py</code> <pre><code>def generate_models(entities: list[EntitySchema], output_dir: Path) -&gt; list[Path]:\n    \"\"\"Generate Pydantic models for all entities.\n\n    Args:\n        entities: List of entity schemas.\n        output_dir: Base directory for generated model files.\n\n    Returns:\n        List of paths to generated files.\n    \"\"\"\n    models_dir = output_dir / \"_generated\" / \"models\"\n    paths: list[Path] = []\n\n    # Generate __init__.py that re-exports all models\n    init_lines = [\n        \"# AUTO-GENERATED by ninja-codegen \u2014 DO NOT EDIT\",\n        \"\",\n    ]\n    for entity in entities:\n        path = generate_model(entity, models_dir)\n        paths.append(path)\n        init_lines.append(f\"from .{entity.name.lower()} import {entity.name}\")\n\n    if entities:\n        init_lines.append(\"\")\n        all_names = \", \".join(repr(e.name) for e in entities)\n        init_lines.append(f\"__all__ = [{all_names}]\")\n        init_lines.append(\"\")\n\n    init_path = models_dir / \"__init__.py\"\n    write_generated_file(init_path, \"\\n\".join(init_lines))\n    paths.append(init_path)\n\n    return paths\n</code></pre>"},{"location":"api/codegen/generators/#agents-generator","title":"Agents Generator","text":""},{"location":"api/codegen/generators/#ninja_codegen.generators.agents","title":"agents","text":"<p>Generate DataAgent, DomainAgent, and CoordinatorAgent code from ASD definitions.</p>"},{"location":"api/codegen/generators/#ninja_codegen.generators.agents.generate_data_agent","title":"generate_data_agent","text":"<pre><code>generate_data_agent(\n    entity: EntitySchema, output_dir: Path\n) -&gt; Path\n</code></pre> <p>Generate a DataAgent file for a single entity.</p> PARAMETER DESCRIPTION <code>entity</code> <p>The entity schema to generate from.</p> <p> TYPE: <code>EntitySchema</code> </p> <code>output_dir</code> <p>Directory to write the generated file into.</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>Path</code> <p>Path to the generated file.</p> Source code in <code>libs/ninja-codegen/src/ninja_codegen/generators/agents.py</code> <pre><code>def generate_data_agent(entity: EntitySchema, output_dir: Path) -&gt; Path:\n    \"\"\"Generate a DataAgent file for a single entity.\n\n    Args:\n        entity: The entity schema to generate from.\n        output_dir: Directory to write the generated file into.\n\n    Returns:\n        Path to the generated file.\n    \"\"\"\n    env = get_template_env()\n    template = env.get_template(\"data_agent.py.j2\")\n    content = template.render(entity=entity)\n\n    file_path = output_dir / f\"{entity.name.lower()}_agent.py\"\n    write_generated_file(file_path, content)\n    return file_path\n</code></pre>"},{"location":"api/codegen/generators/#ninja_codegen.generators.agents.generate_domain_agent","title":"generate_domain_agent","text":"<pre><code>generate_domain_agent(\n    domain: DomainSchema, output_dir: Path\n) -&gt; Path\n</code></pre> <p>Generate a DomainAgent file for a single domain.</p> PARAMETER DESCRIPTION <code>domain</code> <p>The domain schema to generate from.</p> <p> TYPE: <code>DomainSchema</code> </p> <code>output_dir</code> <p>Directory to write the generated file into.</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>Path</code> <p>Path to the generated file.</p> Source code in <code>libs/ninja-codegen/src/ninja_codegen/generators/agents.py</code> <pre><code>def generate_domain_agent(domain: DomainSchema, output_dir: Path) -&gt; Path:\n    \"\"\"Generate a DomainAgent file for a single domain.\n\n    Args:\n        domain: The domain schema to generate from.\n        output_dir: Directory to write the generated file into.\n\n    Returns:\n        Path to the generated file.\n    \"\"\"\n    env = get_template_env()\n    template = env.get_template(\"domain_agent.py.j2\")\n    content = template.render(domain=domain)\n\n    file_path = output_dir / f\"{domain.name.lower()}_agent.py\"\n    write_generated_file(file_path, content)\n    return file_path\n</code></pre>"},{"location":"api/codegen/generators/#ninja_codegen.generators.agents.generate_coordinator","title":"generate_coordinator","text":"<pre><code>generate_coordinator(\n    domains: list[DomainSchema], output_dir: Path\n) -&gt; Path\n</code></pre> <p>Generate a CoordinatorAgent file wiring all domain agents.</p> PARAMETER DESCRIPTION <code>domains</code> <p>List of domain schemas to wire together.</p> <p> TYPE: <code>list[DomainSchema]</code> </p> <code>output_dir</code> <p>Directory to write the generated file into.</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>Path</code> <p>Path to the generated file.</p> Source code in <code>libs/ninja-codegen/src/ninja_codegen/generators/agents.py</code> <pre><code>def generate_coordinator(domains: list[DomainSchema], output_dir: Path) -&gt; Path:\n    \"\"\"Generate a CoordinatorAgent file wiring all domain agents.\n\n    Args:\n        domains: List of domain schemas to wire together.\n        output_dir: Directory to write the generated file into.\n\n    Returns:\n        Path to the generated file.\n    \"\"\"\n    env = get_template_env()\n    template = env.get_template(\"coordinator_agent.py.j2\")\n    domain_names = [d.name for d in domains]\n    content = template.render(domains=domains, domain_names=domain_names)\n\n    file_path = output_dir / \"coordinator_agent.py\"\n    write_generated_file(file_path, content)\n    return file_path\n</code></pre>"},{"location":"api/codegen/generators/#ninja_codegen.generators.agents.generate_agents","title":"generate_agents","text":"<pre><code>generate_agents(\n    entities: list[EntitySchema],\n    domains: list[DomainSchema],\n    output_dir: Path,\n) -&gt; list[Path]\n</code></pre> <p>Generate all agent files (data + domain + coordinator).</p> PARAMETER DESCRIPTION <code>entities</code> <p>List of entity schemas.</p> <p> TYPE: <code>list[EntitySchema]</code> </p> <code>domains</code> <p>List of domain schemas.</p> <p> TYPE: <code>list[DomainSchema]</code> </p> <code>output_dir</code> <p>Base directory for generated agent files.</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>list[Path]</code> <p>List of paths to generated files.</p> Source code in <code>libs/ninja-codegen/src/ninja_codegen/generators/agents.py</code> <pre><code>def generate_agents(\n    entities: list[EntitySchema],\n    domains: list[DomainSchema],\n    output_dir: Path,\n) -&gt; list[Path]:\n    \"\"\"Generate all agent files (data + domain + coordinator).\n\n    Args:\n        entities: List of entity schemas.\n        domains: List of domain schemas.\n        output_dir: Base directory for generated agent files.\n\n    Returns:\n        List of paths to generated files.\n    \"\"\"\n    agents_dir = output_dir / \"_generated\" / \"agents\"\n    paths: list[Path] = []\n\n    # Generate data agents\n    init_lines = [\n        \"# AUTO-GENERATED by ninja-codegen \u2014 DO NOT EDIT\",\n        \"\",\n    ]\n\n    for entity in entities:\n        path = generate_data_agent(entity, agents_dir)\n        paths.append(path)\n        init_lines.append(\n            f\"from .{entity.name.lower()}_agent import {entity.name.upper()}_ENTITY, {entity.name.lower()}_data_agent\"\n        )\n\n    # Generate domain agents\n    for domain in domains:\n        path = generate_domain_agent(domain, agents_dir)\n        paths.append(path)\n        init_lines.append(\n            f\"from .{domain.name.lower()}_agent import {domain.name.upper()}_DOMAIN\"\n            f\", create_{domain.name.lower()}_domain_agent\"\n        )\n\n    # Generate coordinator agent\n    if domains:\n        path = generate_coordinator(domains, agents_dir)\n        paths.append(path)\n        init_lines.append(\"from .coordinator_agent import create_coordinator\")\n\n    if entities or domains:\n        init_lines.append(\"\")\n\n    init_path = agents_dir / \"__init__.py\"\n    write_generated_file(init_path, \"\\n\".join(init_lines))\n    paths.append(init_path)\n\n    return paths\n</code></pre>"},{"location":"api/codegen/generators/#graphql-generator","title":"GraphQL Generator","text":""},{"location":"api/codegen/generators/#ninja_codegen.generators.graphql","title":"graphql","text":"<p>Generate Strawberry GraphQL types and resolvers from EntitySchema definitions.</p>"},{"location":"api/codegen/generators/#ninja_codegen.generators.graphql.generate_gql_type","title":"generate_gql_type","text":"<pre><code>generate_gql_type(\n    entity: EntitySchema, output_dir: Path\n) -&gt; Path\n</code></pre> <p>Generate GraphQL type and resolver stubs for a single entity.</p> PARAMETER DESCRIPTION <code>entity</code> <p>The entity schema to generate from.</p> <p> TYPE: <code>EntitySchema</code> </p> <code>output_dir</code> <p>Directory to write the generated file into.</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>Path</code> <p>Path to the generated file.</p> Source code in <code>libs/ninja-codegen/src/ninja_codegen/generators/graphql.py</code> <pre><code>def generate_gql_type(entity: EntitySchema, output_dir: Path) -&gt; Path:\n    \"\"\"Generate GraphQL type and resolver stubs for a single entity.\n\n    Args:\n        entity: The entity schema to generate from.\n        output_dir: Directory to write the generated file into.\n\n    Returns:\n        Path to the generated file.\n    \"\"\"\n    env = get_template_env()\n    template = env.get_template(\"gql_type.py.j2\")\n\n    content = template.render(\n        entity=entity,\n        fields_meta=build_fields_meta(entity),\n        has_uuid=_has_field_type(entity, \"uuid\"),\n        has_datetime=_has_field_type(entity, \"datetime\"),\n        has_date=_has_field_type(entity, \"date\"),\n    )\n\n    file_path = output_dir / f\"{entity.name.lower()}_gql.py\"\n    write_generated_file(file_path, content)\n    return file_path\n</code></pre>"},{"location":"api/codegen/generators/#ninja_codegen.generators.graphql.generate_graphql","title":"generate_graphql","text":"<pre><code>generate_graphql(\n    entities: list[EntitySchema], output_dir: Path\n) -&gt; list[Path]\n</code></pre> <p>Generate GraphQL types and resolvers for all entities.</p> PARAMETER DESCRIPTION <code>entities</code> <p>List of entity schemas.</p> <p> TYPE: <code>list[EntitySchema]</code> </p> <code>output_dir</code> <p>Base directory for generated GQL files.</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>list[Path]</code> <p>List of paths to generated files.</p> Source code in <code>libs/ninja-codegen/src/ninja_codegen/generators/graphql.py</code> <pre><code>def generate_graphql(entities: list[EntitySchema], output_dir: Path) -&gt; list[Path]:\n    \"\"\"Generate GraphQL types and resolvers for all entities.\n\n    Args:\n        entities: List of entity schemas.\n        output_dir: Base directory for generated GQL files.\n\n    Returns:\n        List of paths to generated files.\n    \"\"\"\n    gql_dir = output_dir / \"_generated\" / \"graphql\"\n    paths: list[Path] = []\n\n    init_lines = [\n        \"# AUTO-GENERATED by ninja-codegen \u2014 DO NOT EDIT\",\n        \"\",\n    ]\n\n    for entity in entities:\n        path = generate_gql_type(entity, gql_dir)\n        paths.append(path)\n        init_lines.append(\n            f\"from .{entity.name.lower()}_gql import \"\n            f\"{entity.name}Type, {entity.name}Input, \"\n            f\"{entity.name}Query, {entity.name}Mutation\"\n        )\n\n    if entities:\n        init_lines.append(\"\")\n\n    init_path = gql_dir / \"__init__.py\"\n    write_generated_file(init_path, \"\\n\".join(init_lines))\n    paths.append(init_path)\n\n    return paths\n</code></pre>"},{"location":"api/codegen/generators/#app-shell-generator","title":"App Shell Generator","text":""},{"location":"api/codegen/generators/#ninja_codegen.generators.apps","title":"apps","text":"<p>Generate thin FastAPI app shells.</p>"},{"location":"api/codegen/generators/#ninja_codegen.generators.apps.generate_app_shell","title":"generate_app_shell","text":"<pre><code>generate_app_shell(\n    project_name: str, output_dir: Path\n) -&gt; Path\n</code></pre> <p>Generate a FastAPI app shell.</p> PARAMETER DESCRIPTION <code>project_name</code> <p>Name of the project.</p> <p> TYPE: <code>str</code> </p> <code>output_dir</code> <p>Base directory for generated app files.</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>Path</code> <p>Path to the generated file.</p> Source code in <code>libs/ninja-codegen/src/ninja_codegen/generators/apps.py</code> <pre><code>def generate_app_shell(project_name: str, output_dir: Path) -&gt; Path:\n    \"\"\"Generate a FastAPI app shell.\n\n    Args:\n        project_name: Name of the project.\n        output_dir: Base directory for generated app files.\n\n    Returns:\n        Path to the generated file.\n    \"\"\"\n    env = get_template_env()\n    template = env.get_template(\"app_shell.py.j2\")\n\n    content = template.render(project_name=project_name)\n\n    apps_dir = output_dir / \"_generated\" / \"app\"\n    file_path = apps_dir / \"main.py\"\n    write_generated_file(file_path, content)\n\n    # Write __init__.py\n    init_content = \"# AUTO-GENERATED by ninja-codegen \u2014 DO NOT EDIT\\n\\nfrom .main import app\\n\\n__all__ = ['app']\\n\"\n    init_path = apps_dir / \"__init__.py\"\n    write_generated_file(init_path, init_content)\n\n    return file_path\n</code></pre>"},{"location":"api/core/agent-config/","title":"Agent config","text":""},{"location":"api/core/agent-config/#ninja_core.schema.agent","title":"agent","text":"<p>Agent configuration models for the Agentic Schema Definition.</p>"},{"location":"api/core/agent-config/#ninja_core.schema.agent.ReasoningLevel","title":"ReasoningLevel","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>How much LLM reasoning an agent should apply.</p>"},{"location":"api/core/agent-config/#ninja_core.schema.agent.AgentConfig","title":"AgentConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for an Expert Agent attached to a domain.</p>"},{"location":"api/core/domain/","title":"Domain","text":""},{"location":"api/core/domain/#ninja_core.schema.domain","title":"domain","text":"<p>Domain schema definitions for the Agentic Schema Definition.</p>"},{"location":"api/core/domain/#ninja_core.schema.domain.DomainSchema","title":"DomainSchema","text":"<p>               Bases: <code>BaseModel</code></p> <p>Logical grouping of entities under one Expert Agent domain.</p>"},{"location":"api/core/entity/","title":"Core Schema","text":""},{"location":"api/core/entity/#ninja_core.schema.entity","title":"entity","text":"<p>Entity and field schema definitions for the Agentic Schema Definition.</p>"},{"location":"api/core/entity/#ninja_core.schema.entity.StorageEngine","title":"StorageEngine","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Database engine that owns an entity.</p>"},{"location":"api/core/entity/#ninja_core.schema.entity.FieldType","title":"FieldType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported field types across all storage engines.</p>"},{"location":"api/core/entity/#ninja_core.schema.entity.EmbeddingConfig","title":"EmbeddingConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for vectorizing a field.</p>"},{"location":"api/core/entity/#ninja_core.schema.entity.FieldConstraint","title":"FieldConstraint","text":"<p>               Bases: <code>BaseModel</code></p> <p>Validation constraints for a field.</p>"},{"location":"api/core/entity/#ninja_core.schema.entity.FieldSchema","title":"FieldSchema","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema definition for a single field within an entity.</p>"},{"location":"api/core/entity/#ninja_core.schema.entity.EntitySchema","title":"EntitySchema","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema definition for an entity (table, collection, node, or vector store).</p>"},{"location":"api/core/project/","title":"Project","text":""},{"location":"api/core/project/#ninja_core.schema.project","title":"project","text":"<p>Top-level Agentic Schema Definition container.</p>"},{"location":"api/core/project/#ninja_core.schema.project.AgenticSchema","title":"AgenticSchema","text":"<p>               Bases: <code>BaseModel</code></p> <p>Top-level ASD container \u2014 the full project definition.</p> <p>This is what gets serialized to / deserialized from <code>.ninjastack/schema.json</code>.</p>"},{"location":"api/core/relationship/","title":"Relationship","text":""},{"location":"api/core/relationship/#ninja_core.schema.relationship","title":"relationship","text":"<p>Relationship schema definitions for the Agentic Schema Definition.</p>"},{"location":"api/core/relationship/#ninja_core.schema.relationship.RelationshipType","title":"RelationshipType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Type of relationship between entities.</p>"},{"location":"api/core/relationship/#ninja_core.schema.relationship.Cardinality","title":"Cardinality","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Cardinality of a relationship.</p>"},{"location":"api/core/relationship/#ninja_core.schema.relationship.RelationshipSchema","title":"RelationshipSchema","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema definition for a relationship between two entities.</p>"},{"location":"api/graphql/","title":"GraphQL API","text":""},{"location":"api/graphql/#ninja_gql","title":"ninja_gql","text":"<p>ninja-gql \u2014 GraphQL layer generator for Ninja Stack.</p>"},{"location":"api/graphql/#ninja_gql.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['GqlGenerator', 'build_schema']\n</code></pre>"},{"location":"api/graphql/#ninja_gql.GqlGenerator","title":"GqlGenerator","text":"<pre><code>GqlGenerator(schema: AgenticSchema)\n</code></pre> <p>Generates Strawberry types, input types, queries, and mutations from an ASD.</p> Source code in <code>libs/ninja-gql/src/ninja_gql/generator.py</code> <pre><code>def __init__(self, schema: AgenticSchema) -&gt; None:\n    self.schema = schema\n    self._types: dict[str, type] = {}\n    self._input_types: dict[str, type] = {}\n    self._entity_map: dict[str, EntitySchema] = {e.name: e for e in schema.entities}\n    self._rel_by_source: dict[str, list[RelationshipSchema]] = {}\n    for rel in schema.relationships:\n        self._rel_by_source.setdefault(rel.source_entity, []).append(rel)\n</code></pre>"},{"location":"api/graphql/#ninja_gql.GqlGenerator.schema","title":"schema  <code>instance-attribute</code>","text":"<pre><code>schema = schema\n</code></pre>"},{"location":"api/graphql/#ninja_gql.GqlGenerator.generate_types","title":"generate_types","text":"<pre><code>generate_types() -&gt; dict[str, type]\n</code></pre> <p>Create a Strawberry <code>@strawberry.type</code> class per entity.</p> <p>Returns a mapping <code>{EntityName: StrawberryType}</code>.</p> Source code in <code>libs/ninja-gql/src/ninja_gql/generator.py</code> <pre><code>def generate_types(self) -&gt; dict[str, type]:\n    \"\"\"Create a Strawberry ``@strawberry.type`` class per entity.\n\n    Returns a mapping ``{EntityName: StrawberryType}``.\n    \"\"\"\n    if self._types:\n        return self._types\n\n    # First pass: create basic types (no relationships yet)\n    for entity in self.schema.entities:\n        self._types[entity.name] = self._make_type(entity)\n\n    # Second pass: wire relationship fields\n    for entity in self.schema.entities:\n        self._attach_relationships(entity)\n\n    return self._types\n</code></pre>"},{"location":"api/graphql/#ninja_gql.GqlGenerator.generate_input_types","title":"generate_input_types","text":"<pre><code>generate_input_types() -&gt; dict[str, tuple[type, type]]\n</code></pre> <p>Create Strawberry input types for create and update operations.</p> <p>Returns <code>{EntityName: (CreateInput, UpdateInput)}</code>.</p> Source code in <code>libs/ninja-gql/src/ninja_gql/generator.py</code> <pre><code>def generate_input_types(self) -&gt; dict[str, tuple[type, type]]:\n    \"\"\"Create Strawberry input types for create and update operations.\n\n    Returns ``{EntityName: (CreateInput, UpdateInput)}``.\n    \"\"\"\n    if self._input_types:\n        return self._input_types\n\n    for entity in self.schema.entities:\n        create_cls, update_cls = self._make_input_types(entity)\n        self._input_types[entity.name] = (create_cls, update_cls)\n    return self._input_types\n</code></pre>"},{"location":"api/graphql/#ninja_gql.GqlGenerator.get_type","title":"get_type","text":"<pre><code>get_type(entity_name: str) -&gt; type\n</code></pre> <p>Return the generated Strawberry type for entity_name.</p> Source code in <code>libs/ninja-gql/src/ninja_gql/generator.py</code> <pre><code>def get_type(self, entity_name: str) -&gt; type:\n    \"\"\"Return the generated Strawberry type for *entity_name*.\"\"\"\n    if not self._types:\n        self.generate_types()\n    return self._types[entity_name]\n</code></pre>"},{"location":"api/graphql/#ninja_gql.GqlGenerator.has_embeddable_fields","title":"has_embeddable_fields","text":"<pre><code>has_embeddable_fields(entity: EntitySchema) -&gt; bool\n</code></pre> <p>Return True if the entity has any field with embedding config.</p> Source code in <code>libs/ninja-gql/src/ninja_gql/generator.py</code> <pre><code>def has_embeddable_fields(self, entity: EntitySchema) -&gt; bool:\n    \"\"\"Return True if the entity has any field with embedding config.\"\"\"\n    return any(f.embedding is not None for f in entity.fields)\n</code></pre>"},{"location":"api/graphql/#ninja_gql.build_schema","title":"build_schema","text":"<pre><code>build_schema(\n    asd: AgenticSchema,\n    repo_getter: Callable[[str], Repository[Any]]\n    | None = None,\n    agent_router: AgentRouter | None = None,\n) -&gt; Schema\n</code></pre> <p>Build a Strawberry <code>Schema</code> from an Agentic Schema Definition.</p>"},{"location":"api/graphql/#ninja_gql.build_schema--parameters","title":"Parameters","text":"<p>asd:     The project's ASD. repo_getter:     A callable <code>(entity_name) -&gt; Repository</code>.  When <code>None</code> a stub     that raises at call-time is used (useful for schema-only validation). agent_router:     Optional agent router for <code>ask_*</code> queries.</p> Source code in <code>libs/ninja-gql/src/ninja_gql/schema.py</code> <pre><code>def build_schema(\n    asd: AgenticSchema,\n    repo_getter: Callable[[str], Repository[Any]] | None = None,\n    agent_router: AgentRouter | None = None,\n) -&gt; strawberry.Schema:\n    \"\"\"Build a Strawberry ``Schema`` from an Agentic Schema Definition.\n\n    Parameters\n    ----------\n    asd:\n        The project's ASD.\n    repo_getter:\n        A callable ``(entity_name) -&gt; Repository``.  When ``None`` a stub\n        that raises at call-time is used (useful for schema-only validation).\n    agent_router:\n        Optional agent router for ``ask_*`` queries.\n    \"\"\"\n    gen = GqlGenerator(asd)\n    types = gen.generate_types()\n    gen.generate_input_types()\n\n    if repo_getter is None:\n\n        def _no_repo(name: str) -&gt; Repository[Any]:\n            raise RuntimeError(f\"No repository configured for {name}\")\n\n        repo_getter = _no_repo\n\n    # -- build Query fields --------------------------------------------------\n    query_annotations: dict[str, Any] = {}\n    query_ns: dict[str, Any] = {\"__annotations__\": query_annotations}\n\n    for entity in asd.entities:\n        gql_type = types[entity.name]\n        snake = _snake(entity.name)\n\n        # get\n        get_name = f\"get_{snake}\"\n        get_fn = make_get_resolver(entity, gql_type, repo_getter)\n        query_ns[get_name] = strawberry.field(resolver=get_fn)\n\n        # list\n        list_name = f\"list_{snake}\"\n        list_fn = make_list_resolver(entity, gql_type, repo_getter)\n        query_ns[list_name] = strawberry.field(resolver=list_fn)\n\n        # semantic search (only for entities with embeddable fields)\n        if gen.has_embeddable_fields(entity):\n            search_name = f\"search_{snake}\"\n            search_fn = make_search_resolver(entity, gql_type, repo_getter)\n            query_ns[search_name] = strawberry.field(resolver=search_fn)\n\n    # agent queries per domain\n    for domain in asd.domains:\n        ask_name = f\"ask_{domain.name.lower().replace(' ', '_')}\"\n        ask_fn = make_agent_query_resolver(domain.name, agent_router)\n        query_ns[ask_name] = strawberry.field(resolver=ask_fn)\n\n    query_cls = type(\"Query\", (), query_ns)\n    Query = strawberry.type(query_cls, description=\"Auto-generated root Query\")\n\n    # -- build Mutation fields -----------------------------------------------\n    mutation_annotations: dict[str, Any] = {}\n    mutation_ns: dict[str, Any] = {\"__annotations__\": mutation_annotations}\n\n    for entity in asd.entities:\n        gql_type = types[entity.name]\n        snake = _snake(entity.name)\n\n        create_fn = make_create_resolver(entity, gql_type, repo_getter)\n        mutation_ns[f\"create_{snake}\"] = strawberry.mutation(resolver=create_fn)\n\n        update_fn = make_update_resolver(entity, gql_type, repo_getter)\n        mutation_ns[f\"update_{snake}\"] = strawberry.mutation(resolver=update_fn)\n\n        delete_fn = make_delete_resolver(entity, repo_getter)\n        mutation_ns[f\"delete_{snake}\"] = strawberry.mutation(resolver=delete_fn)\n\n    mutation_cls = type(\"Mutation\", (), mutation_ns)\n    Mutation = strawberry.type(mutation_cls, description=\"Auto-generated root Mutation\")\n\n    return strawberry.Schema(query=Query, mutation=Mutation)\n</code></pre>"},{"location":"api/introspect/","title":"Introspection API","text":""},{"location":"api/introspect/#ninja_introspect","title":"ninja_introspect","text":"<p>ninja-introspect \u2014 Polyglot database introspection engine for Ninja Stack.</p>"},{"location":"api/introspect/#ninja_introspect.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"GraphProvider\",\n    \"IntrospectionEngine\",\n    \"IntrospectionProvider\",\n    \"IntrospectionResult\",\n    \"MongoProvider\",\n    \"SQLProvider\",\n    \"VectorProvider\",\n]\n</code></pre>"},{"location":"api/introspect/#ninja_introspect.IntrospectionEngine","title":"IntrospectionEngine","text":"<pre><code>IntrospectionEngine(project_name: str = 'untitled')\n</code></pre> <p>Orchestrates multiple introspection providers and merges their results.</p> <p>Usage::</p> <pre><code>engine = IntrospectionEngine(project_name=\"my-project\")\nschema = await engine.run([\n    \"sqlite+aiosqlite:///path/to/db.sqlite\",\n    \"mongodb://localhost:27017/mydb\",\n])\n</code></pre> Source code in <code>libs/ninja-introspect/src/ninja_introspect/engine.py</code> <pre><code>def __init__(self, project_name: str = \"untitled\") -&gt; None:\n    self.project_name = project_name\n</code></pre>"},{"location":"api/introspect/#ninja_introspect.IntrospectionEngine.project_name","title":"project_name  <code>instance-attribute</code>","text":"<pre><code>project_name = project_name\n</code></pre>"},{"location":"api/introspect/#ninja_introspect.IntrospectionEngine.run","title":"run  <code>async</code>","text":"<pre><code>run(\n    connection_strings: list[str],\n    *,\n    providers: dict[str, IntrospectionProvider]\n    | None = None,\n) -&gt; AgenticSchema\n</code></pre> <p>Run introspection across all connection strings and merge results.</p> PARAMETER DESCRIPTION <code>connection_strings</code> <p>List of database connection URIs.</p> <p> TYPE: <code>list[str]</code> </p> <code>providers</code> <p>Optional mapping of connection string \u2192 provider override.</p> <p> TYPE: <code>dict[str, IntrospectionProvider] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AgenticSchema</code> <p>A merged AgenticSchema containing entities and relationships from all sources.</p> Source code in <code>libs/ninja-introspect/src/ninja_introspect/engine.py</code> <pre><code>async def run(\n    self,\n    connection_strings: list[str],\n    *,\n    providers: dict[str, IntrospectionProvider] | None = None,\n) -&gt; AgenticSchema:\n    \"\"\"Run introspection across all connection strings and merge results.\n\n    Args:\n        connection_strings: List of database connection URIs.\n        providers: Optional mapping of connection string \u2192 provider override.\n\n    Returns:\n        A merged AgenticSchema containing entities and relationships from all sources.\n    \"\"\"\n    all_entities: list[EntitySchema] = []\n    all_relationships: list[RelationshipSchema] = []\n\n    for conn_str in connection_strings:\n        if providers and conn_str in providers:\n            provider = providers[conn_str]\n        else:\n            provider = _detect_provider(conn_str)\n\n        result: IntrospectionResult = await provider.introspect(conn_str)\n        all_entities.extend(result.entities)\n        all_relationships.extend(result.relationships)\n\n    return AgenticSchema(\n        project_name=self.project_name,\n        entities=all_entities,\n        relationships=all_relationships,\n    )\n</code></pre>"},{"location":"api/introspect/#ninja_introspect.IntrospectionProvider","title":"IntrospectionProvider","text":"<p>               Bases: <code>ABC</code></p> <p>Protocol for database introspection providers.</p> <p>Each provider connects to a specific database type, reads its schema, and produces EntitySchema + RelationshipSchema objects.</p>"},{"location":"api/introspect/#ninja_introspect.IntrospectionProvider.introspect","title":"introspect  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>introspect(connection_string: str) -&gt; IntrospectionResult\n</code></pre> <p>Connect to the database and extract schema information.</p> PARAMETER DESCRIPTION <code>connection_string</code> <p>Database connection URI.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>IntrospectionResult</code> <p>IntrospectionResult containing discovered entities and relationships.</p> Source code in <code>libs/ninja-introspect/src/ninja_introspect/providers/base.py</code> <pre><code>@abstractmethod\nasync def introspect(self, connection_string: str) -&gt; IntrospectionResult:\n    \"\"\"Connect to the database and extract schema information.\n\n    Args:\n        connection_string: Database connection URI.\n\n    Returns:\n        IntrospectionResult containing discovered entities and relationships.\n    \"\"\"\n</code></pre>"},{"location":"api/introspect/#ninja_introspect.IntrospectionResult","title":"IntrospectionResult  <code>dataclass</code>","text":"<pre><code>IntrospectionResult(\n    entities: list[EntitySchema] = list(),\n    relationships: list[RelationshipSchema] = list(),\n)\n</code></pre> <p>Result from a single provider's introspection run.</p>"},{"location":"api/introspect/#ninja_introspect.IntrospectionResult.entities","title":"entities  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entities: list[EntitySchema] = field(default_factory=list)\n</code></pre>"},{"location":"api/introspect/#ninja_introspect.IntrospectionResult.relationships","title":"relationships  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>relationships: list[RelationshipSchema] = field(\n    default_factory=list\n)\n</code></pre>"},{"location":"api/introspect/#ninja_introspect.GraphProvider","title":"GraphProvider","text":"<pre><code>GraphProvider(sample_size: int = DEFAULT_SAMPLE_SIZE)\n</code></pre> <p>               Bases: <code>IntrospectionProvider</code></p> <p>Introspects Neo4j graph databases \u2014 reads node labels, relationship types, and properties.</p> Source code in <code>libs/ninja-introspect/src/ninja_introspect/providers/graph.py</code> <pre><code>def __init__(self, sample_size: int = DEFAULT_SAMPLE_SIZE) -&gt; None:\n    self.sample_size = sample_size\n</code></pre>"},{"location":"api/introspect/#ninja_introspect.GraphProvider.sample_size","title":"sample_size  <code>instance-attribute</code>","text":"<pre><code>sample_size = sample_size\n</code></pre>"},{"location":"api/introspect/#ninja_introspect.GraphProvider.introspect","title":"introspect  <code>async</code>","text":"<pre><code>introspect(connection_string: str) -&gt; IntrospectionResult\n</code></pre> Source code in <code>libs/ninja-introspect/src/ninja_introspect/providers/graph.py</code> <pre><code>async def introspect(self, connection_string: str) -&gt; IntrospectionResult:\n    driver = AsyncGraphDatabase.driver(connection_string)\n    try:\n        return await self._run_introspection(driver)\n    finally:\n        await driver.close()\n</code></pre>"},{"location":"api/introspect/#ninja_introspect.MongoProvider","title":"MongoProvider","text":"<pre><code>MongoProvider(sample_size: int = DEFAULT_SAMPLE_SIZE)\n</code></pre> <p>               Bases: <code>IntrospectionProvider</code></p> <p>Introspects MongoDB databases by sampling documents to infer schema.</p> Source code in <code>libs/ninja-introspect/src/ninja_introspect/providers/mongo.py</code> <pre><code>def __init__(self, sample_size: int = DEFAULT_SAMPLE_SIZE) -&gt; None:\n    self.sample_size = sample_size\n</code></pre>"},{"location":"api/introspect/#ninja_introspect.MongoProvider.sample_size","title":"sample_size  <code>instance-attribute</code>","text":"<pre><code>sample_size = sample_size\n</code></pre>"},{"location":"api/introspect/#ninja_introspect.MongoProvider.introspect","title":"introspect  <code>async</code>","text":"<pre><code>introspect(connection_string: str) -&gt; IntrospectionResult\n</code></pre> Source code in <code>libs/ninja-introspect/src/ninja_introspect/providers/mongo.py</code> <pre><code>async def introspect(self, connection_string: str) -&gt; IntrospectionResult:\n    client: AsyncIOMotorClient = AsyncIOMotorClient(connection_string)  # type: ignore[type-arg]\n    try:\n        db_name = client.get_default_database().name  # type: ignore[union-attr]\n        db = client[db_name]\n\n        collection_names: list[str] = await db.list_collection_names()\n        # Filter out system collections\n        collection_names = [c for c in collection_names if not c.startswith(\"system.\")]\n\n        entities: list[EntitySchema] = []\n        for coll_name in sorted(collection_names):\n            entity = await self._introspect_collection(db, coll_name)\n            if entity is not None:\n                entities.append(entity)\n\n        return IntrospectionResult(entities=entities)\n    finally:\n        client.close()\n</code></pre>"},{"location":"api/introspect/#ninja_introspect.SQLProvider","title":"SQLProvider","text":"<p>               Bases: <code>IntrospectionProvider</code></p> <p>Introspects SQL databases (Postgres, MySQL, SQLite) via SQLAlchemy.</p>"},{"location":"api/introspect/#ninja_introspect.SQLProvider.introspect","title":"introspect  <code>async</code>","text":"<pre><code>introspect(connection_string: str) -&gt; IntrospectionResult\n</code></pre> Source code in <code>libs/ninja-introspect/src/ninja_introspect/providers/sql.py</code> <pre><code>async def introspect(self, connection_string: str) -&gt; IntrospectionResult:\n    engine = create_async_engine(connection_string)\n    try:\n        return await self._run_introspection(engine)\n    finally:\n        await engine.dispose()\n</code></pre>"},{"location":"api/introspect/#ninja_introspect.VectorProvider","title":"VectorProvider","text":"<p>               Bases: <code>IntrospectionProvider</code></p> <p>Introspects vector databases (Chroma) \u2014 reads collection metadata.</p>"},{"location":"api/introspect/#ninja_introspect.VectorProvider.introspect","title":"introspect  <code>async</code>","text":"<pre><code>introspect(connection_string: str) -&gt; IntrospectionResult\n</code></pre> <p>Introspect a Chroma vector database.</p> PARAMETER DESCRIPTION <code>connection_string</code> <p>For Chroma, this is the persist directory path or an HTTP URL like <code>http://host:port</code>.</p> <p> TYPE: <code>str</code> </p> Source code in <code>libs/ninja-introspect/src/ninja_introspect/providers/vector.py</code> <pre><code>async def introspect(self, connection_string: str) -&gt; IntrospectionResult:\n    \"\"\"Introspect a Chroma vector database.\n\n    Args:\n        connection_string: For Chroma, this is the persist directory path\n            or an HTTP URL like ``http://host:port``.\n    \"\"\"\n    client = self._create_client(connection_string)\n    collections = client.list_collections()\n\n    entities: list[EntitySchema] = []\n    for collection in collections:\n        entity = self._introspect_collection(collection)\n        entities.append(entity)\n\n    return IntrospectionResult(entities=entities)\n</code></pre>"},{"location":"api/persistence/","title":"Persistence API","text":""},{"location":"api/persistence/#ninja_persistence","title":"ninja_persistence","text":"<p>Ninja Persistence \u2014 unified polyglot persistence layer for Ninja Stack.</p>"},{"location":"api/persistence/#ninja_persistence.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = [\n    \"AdapterRegistry\",\n    \"ChromaVectorAdapter\",\n    \"ConnectionManager\",\n    \"ConnectionProfile\",\n    \"EmbeddingStrategy\",\n    \"GraphAdapter\",\n    \"MilvusVectorAdapter\",\n    \"MongoAdapter\",\n    \"Repository\",\n    \"SQLAdapter\",\n]\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.ChromaVectorAdapter","title":"ChromaVectorAdapter","text":"<pre><code>ChromaVectorAdapter(\n    entity: EntitySchema, client: Any = None\n)\n</code></pre> <p>Chroma-backed vector store adapter.</p> <p>Implements the Repository protocol with native semantic search support.</p> <p>Requires the <code>chromadb</code> optional dependency:     pip install ninja-persistence[chroma]</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/chroma.py</code> <pre><code>def __init__(self, entity: EntitySchema, client: Any = None) -&gt; None:\n    self._entity = entity\n    self._client = client\n    self._collection_name = entity.collection_name or entity.name.lower()\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.ChromaVectorAdapter.find_by_id","title":"find_by_id  <code>async</code>","text":"<pre><code>find_by_id(id: str) -&gt; dict[str, Any] | None\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/chroma.py</code> <pre><code>async def find_by_id(self, id: str) -&gt; dict[str, Any] | None:\n    coll = self._get_collection()\n    result = coll.get(ids=[id])\n    if not result[\"ids\"]:\n        return None\n    doc: dict[str, Any] = {\"id\": id}\n    if result.get(\"metadatas\"):\n        doc.update(result[\"metadatas\"][0])\n    if result.get(\"documents\"):\n        doc[\"document\"] = result[\"documents\"][0]\n    return doc\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.ChromaVectorAdapter.find_many","title":"find_many  <code>async</code>","text":"<pre><code>find_many(\n    filters: dict[str, Any] | None = None, limit: int = 100\n) -&gt; list[dict[str, Any]]\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/chroma.py</code> <pre><code>async def find_many(self, filters: dict[str, Any] | None = None, limit: int = 100) -&gt; list[dict[str, Any]]:\n    coll = self._get_collection()\n    kwargs: dict[str, Any] = {\"limit\": limit}\n    if filters and \"where\" in filters:\n        kwargs[\"where\"] = filters[\"where\"]\n    result = coll.get(**kwargs)\n    docs: list[dict[str, Any]] = []\n    for i, doc_id in enumerate(result[\"ids\"]):\n        doc: dict[str, Any] = {\"id\": doc_id}\n        if result.get(\"metadatas\") and i &lt; len(result[\"metadatas\"]):\n            doc.update(result[\"metadatas\"][i])\n        if result.get(\"documents\") and i &lt; len(result[\"documents\"]):\n            doc[\"document\"] = result[\"documents\"][i]\n        docs.append(doc)\n    return docs\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.ChromaVectorAdapter.create","title":"create  <code>async</code>","text":"<pre><code>create(data: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/chroma.py</code> <pre><code>async def create(self, data: dict[str, Any]) -&gt; dict[str, Any]:\n    coll = self._get_collection()\n    doc_id = data.get(\"id\", \"\")\n    document = data.get(\"document\", \"\")\n    metadata = {k: v for k, v in data.items() if k not in (\"id\", \"document\", \"embedding\")}\n    embedding = data.get(\"embedding\")\n    kwargs: dict[str, Any] = {\n        \"ids\": [doc_id],\n        \"documents\": [document],\n    }\n    if metadata:\n        kwargs[\"metadatas\"] = [metadata]\n    if embedding:\n        kwargs[\"embeddings\"] = [embedding]\n    coll.add(**kwargs)\n    return data\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.ChromaVectorAdapter.update","title":"update  <code>async</code>","text":"<pre><code>update(\n    id: str, patch: dict[str, Any]\n) -&gt; dict[str, Any] | None\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/chroma.py</code> <pre><code>async def update(self, id: str, patch: dict[str, Any]) -&gt; dict[str, Any] | None:\n    coll = self._get_collection()\n    kwargs: dict[str, Any] = {\"ids\": [id]}\n    if \"document\" in patch:\n        kwargs[\"documents\"] = [patch[\"document\"]]\n    metadata = {k: v for k, v in patch.items() if k not in (\"id\", \"document\", \"embedding\")}\n    if metadata:\n        kwargs[\"metadatas\"] = [metadata]\n    if \"embedding\" in patch:\n        kwargs[\"embeddings\"] = [patch[\"embedding\"]]\n    coll.update(**kwargs)\n    return await self.find_by_id(id)\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.ChromaVectorAdapter.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(id: str) -&gt; bool\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/chroma.py</code> <pre><code>async def delete(self, id: str) -&gt; bool:\n    coll = self._get_collection()\n    coll.delete(ids=[id])\n    return True\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.ChromaVectorAdapter.search_semantic","title":"search_semantic  <code>async</code>","text":"<pre><code>search_semantic(\n    query: str, limit: int = 10\n) -&gt; list[dict[str, Any]]\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/chroma.py</code> <pre><code>async def search_semantic(self, query: str, limit: int = 10) -&gt; list[dict[str, Any]]:\n    coll = self._get_collection()\n    result = coll.query(query_texts=[query], n_results=limit)\n    docs: list[dict[str, Any]] = []\n    if result[\"ids\"] and result[\"ids\"][0]:\n        for i, doc_id in enumerate(result[\"ids\"][0]):\n            doc: dict[str, Any] = {\"id\": doc_id}\n            if result.get(\"metadatas\") and result[\"metadatas\"][0] and i &lt; len(result[\"metadatas\"][0]):\n                doc.update(result[\"metadatas\"][0][i])\n            if result.get(\"documents\") and result[\"documents\"][0] and i &lt; len(result[\"documents\"][0]):\n                doc[\"document\"] = result[\"documents\"][0][i]\n            if result.get(\"distances\") and result[\"distances\"][0] and i &lt; len(result[\"distances\"][0]):\n                doc[\"_distance\"] = result[\"distances\"][0][i]\n            docs.append(doc)\n    return docs\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.ChromaVectorAdapter.upsert_embedding","title":"upsert_embedding  <code>async</code>","text":"<pre><code>upsert_embedding(id: str, embedding: list[float]) -&gt; None\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/chroma.py</code> <pre><code>async def upsert_embedding(self, id: str, embedding: list[float]) -&gt; None:\n    coll = self._get_collection()\n    coll.update(ids=[id], embeddings=[embedding])\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.GraphAdapter","title":"GraphAdapter","text":"<pre><code>GraphAdapter(entity: EntitySchema, driver: Any = None)\n</code></pre> <p>Async Neo4j adapter for graph-backed entities.</p> <p>Implements the Repository protocol for graph databases.</p> <p>Requires the <code>neo4j</code> optional dependency:     pip install ninja-persistence[graph]</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/graph.py</code> <pre><code>def __init__(self, entity: EntitySchema, driver: Any = None) -&gt; None:\n    self._entity = entity\n    self._driver = driver\n    self._label = entity.collection_name or entity.name\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.GraphAdapter.find_by_id","title":"find_by_id  <code>async</code>","text":"<pre><code>find_by_id(id: str) -&gt; dict[str, Any] | None\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/graph.py</code> <pre><code>async def find_by_id(self, id: str) -&gt; dict[str, Any] | None:\n    raise NotImplementedError(\"GraphAdapter.find_by_id is not yet implemented.\")\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.GraphAdapter.find_many","title":"find_many  <code>async</code>","text":"<pre><code>find_many(\n    filters: dict[str, Any] | None = None, limit: int = 100\n) -&gt; list[dict[str, Any]]\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/graph.py</code> <pre><code>async def find_many(self, filters: dict[str, Any] | None = None, limit: int = 100) -&gt; list[dict[str, Any]]:\n    raise NotImplementedError(\"GraphAdapter.find_many is not yet implemented.\")\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.GraphAdapter.create","title":"create  <code>async</code>","text":"<pre><code>create(data: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/graph.py</code> <pre><code>async def create(self, data: dict[str, Any]) -&gt; dict[str, Any]:\n    raise NotImplementedError(\"GraphAdapter.create is not yet implemented.\")\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.GraphAdapter.update","title":"update  <code>async</code>","text":"<pre><code>update(\n    id: str, patch: dict[str, Any]\n) -&gt; dict[str, Any] | None\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/graph.py</code> <pre><code>async def update(self, id: str, patch: dict[str, Any]) -&gt; dict[str, Any] | None:\n    raise NotImplementedError(\"GraphAdapter.update is not yet implemented.\")\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.GraphAdapter.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(id: str) -&gt; bool\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/graph.py</code> <pre><code>async def delete(self, id: str) -&gt; bool:\n    raise NotImplementedError(\"GraphAdapter.delete is not yet implemented.\")\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.GraphAdapter.search_semantic","title":"search_semantic  <code>async</code>","text":"<pre><code>search_semantic(\n    query: str, limit: int = 10\n) -&gt; list[dict[str, Any]]\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/graph.py</code> <pre><code>async def search_semantic(self, query: str, limit: int = 10) -&gt; list[dict[str, Any]]:\n    raise NotImplementedError(\"GraphAdapter.search_semantic is not yet implemented.\")\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.GraphAdapter.upsert_embedding","title":"upsert_embedding  <code>async</code>","text":"<pre><code>upsert_embedding(id: str, embedding: list[float]) -&gt; None\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/graph.py</code> <pre><code>async def upsert_embedding(self, id: str, embedding: list[float]) -&gt; None:\n    raise NotImplementedError(\"GraphAdapter.upsert_embedding is not yet implemented.\")\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.MilvusVectorAdapter","title":"MilvusVectorAdapter","text":"<pre><code>MilvusVectorAdapter(\n    entity: EntitySchema, client: Any = None\n)\n</code></pre> <p>Milvus-backed vector store adapter.</p> <p>Implements the Repository protocol with native semantic search support.</p> <p>Requires the <code>pymilvus</code> optional dependency:     pip install ninja-persistence[milvus]</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/milvus.py</code> <pre><code>def __init__(self, entity: EntitySchema, client: Any = None) -&gt; None:\n    self._entity = entity\n    self._client = client\n    self._collection_name = entity.collection_name or entity.name.lower()\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.MilvusVectorAdapter.find_by_id","title":"find_by_id  <code>async</code>","text":"<pre><code>find_by_id(id: str) -&gt; dict[str, Any] | None\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/milvus.py</code> <pre><code>async def find_by_id(self, id: str) -&gt; dict[str, Any] | None:\n    raise NotImplementedError(\"MilvusVectorAdapter.find_by_id is not yet implemented.\")\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.MilvusVectorAdapter.find_many","title":"find_many  <code>async</code>","text":"<pre><code>find_many(\n    filters: dict[str, Any] | None = None, limit: int = 100\n) -&gt; list[dict[str, Any]]\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/milvus.py</code> <pre><code>async def find_many(self, filters: dict[str, Any] | None = None, limit: int = 100) -&gt; list[dict[str, Any]]:\n    raise NotImplementedError(\"MilvusVectorAdapter.find_many is not yet implemented.\")\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.MilvusVectorAdapter.create","title":"create  <code>async</code>","text":"<pre><code>create(data: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/milvus.py</code> <pre><code>async def create(self, data: dict[str, Any]) -&gt; dict[str, Any]:\n    raise NotImplementedError(\"MilvusVectorAdapter.create is not yet implemented.\")\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.MilvusVectorAdapter.update","title":"update  <code>async</code>","text":"<pre><code>update(\n    id: str, patch: dict[str, Any]\n) -&gt; dict[str, Any] | None\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/milvus.py</code> <pre><code>async def update(self, id: str, patch: dict[str, Any]) -&gt; dict[str, Any] | None:\n    raise NotImplementedError(\"MilvusVectorAdapter.update is not yet implemented.\")\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.MilvusVectorAdapter.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(id: str) -&gt; bool\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/milvus.py</code> <pre><code>async def delete(self, id: str) -&gt; bool:\n    raise NotImplementedError(\"MilvusVectorAdapter.delete is not yet implemented.\")\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.MilvusVectorAdapter.search_semantic","title":"search_semantic  <code>async</code>","text":"<pre><code>search_semantic(\n    query: str, limit: int = 10\n) -&gt; list[dict[str, Any]]\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/milvus.py</code> <pre><code>async def search_semantic(self, query: str, limit: int = 10) -&gt; list[dict[str, Any]]:\n    raise NotImplementedError(\"MilvusVectorAdapter.search_semantic is not yet implemented.\")\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.MilvusVectorAdapter.upsert_embedding","title":"upsert_embedding  <code>async</code>","text":"<pre><code>upsert_embedding(id: str, embedding: list[float]) -&gt; None\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/milvus.py</code> <pre><code>async def upsert_embedding(self, id: str, embedding: list[float]) -&gt; None:\n    raise NotImplementedError(\"MilvusVectorAdapter.upsert_embedding is not yet implemented.\")\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.MongoAdapter","title":"MongoAdapter","text":"<pre><code>MongoAdapter(entity: EntitySchema, database: Any = None)\n</code></pre> <p>Async MongoDB adapter backed by Motor.</p> <p>Implements the Repository protocol for document databases.</p> <p>Requires the <code>motor</code> optional dependency:     pip install ninja-persistence[mongo]</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/mongo.py</code> <pre><code>def __init__(self, entity: EntitySchema, database: Any = None) -&gt; None:\n    self._entity = entity\n    self._database = database\n    self._collection_name = entity.collection_name or entity.name.lower()\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.MongoAdapter.find_by_id","title":"find_by_id  <code>async</code>","text":"<pre><code>find_by_id(id: str) -&gt; dict[str, Any] | None\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/mongo.py</code> <pre><code>async def find_by_id(self, id: str) -&gt; dict[str, Any] | None:\n    coll = self._get_collection()\n    doc = await coll.find_one({\"_id\": id})\n    return dict(doc) if doc else None\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.MongoAdapter.find_many","title":"find_many  <code>async</code>","text":"<pre><code>find_many(\n    filters: dict[str, Any] | None = None, limit: int = 100\n) -&gt; list[dict[str, Any]]\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/mongo.py</code> <pre><code>async def find_many(self, filters: dict[str, Any] | None = None, limit: int = 100) -&gt; list[dict[str, Any]]:\n    coll = self._get_collection()\n    cursor = coll.find(filters or {}).limit(limit)\n    return [dict(doc) async for doc in cursor]\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.MongoAdapter.create","title":"create  <code>async</code>","text":"<pre><code>create(data: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/mongo.py</code> <pre><code>async def create(self, data: dict[str, Any]) -&gt; dict[str, Any]:\n    coll = self._get_collection()\n    await coll.insert_one(data)\n    return data\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.MongoAdapter.update","title":"update  <code>async</code>","text":"<pre><code>update(\n    id: str, patch: dict[str, Any]\n) -&gt; dict[str, Any] | None\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/mongo.py</code> <pre><code>async def update(self, id: str, patch: dict[str, Any]) -&gt; dict[str, Any] | None:\n    coll = self._get_collection()\n    result = await coll.update_one({\"_id\": id}, {\"$set\": patch})\n    if result.matched_count == 0:\n        return None\n    return await self.find_by_id(id)\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.MongoAdapter.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(id: str) -&gt; bool\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/mongo.py</code> <pre><code>async def delete(self, id: str) -&gt; bool:\n    coll = self._get_collection()\n    result = await coll.delete_one({\"_id\": id})\n    return result.deleted_count &gt; 0\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.MongoAdapter.search_semantic","title":"search_semantic  <code>async</code>","text":"<pre><code>search_semantic(\n    query: str, limit: int = 10\n) -&gt; list[dict[str, Any]]\n</code></pre> <p>Semantic search requires a sidecar vector index for Mongo-backed entities.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/mongo.py</code> <pre><code>async def search_semantic(self, query: str, limit: int = 10) -&gt; list[dict[str, Any]]:\n    \"\"\"Semantic search requires a sidecar vector index for Mongo-backed entities.\"\"\"\n    return []\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.MongoAdapter.upsert_embedding","title":"upsert_embedding  <code>async</code>","text":"<pre><code>upsert_embedding(id: str, embedding: list[float]) -&gt; None\n</code></pre> <p>Embedding storage requires a sidecar vector adapter for Mongo-backed entities.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/mongo.py</code> <pre><code>async def upsert_embedding(self, id: str, embedding: list[float]) -&gt; None:\n    \"\"\"Embedding storage requires a sidecar vector adapter for Mongo-backed entities.\"\"\"\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.SQLAdapter","title":"SQLAdapter","text":"<pre><code>SQLAdapter(engine: AsyncEngine, entity: EntitySchema)\n</code></pre> <p>Async SQL adapter backed by SQLAlchemy.</p> <p>Implements the Repository protocol for relational databases.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/sql.py</code> <pre><code>def __init__(self, engine: AsyncEngine, entity: EntitySchema) -&gt; None:\n    self._engine = engine\n    self._entity = entity\n    self._metadata = sa.MetaData()\n    self._table = _build_table(entity, self._metadata)\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.SQLAdapter.table","title":"table  <code>property</code>","text":"<pre><code>table: Table\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.SQLAdapter.ensure_table","title":"ensure_table  <code>async</code>","text":"<pre><code>ensure_table() -&gt; None\n</code></pre> <p>Create the table if it does not exist.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/sql.py</code> <pre><code>async def ensure_table(self) -&gt; None:\n    \"\"\"Create the table if it does not exist.\"\"\"\n    async with self._engine.begin() as conn:\n        await conn.run_sync(self._metadata.create_all)\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.SQLAdapter.find_by_id","title":"find_by_id  <code>async</code>","text":"<pre><code>find_by_id(id: str) -&gt; dict[str, Any] | None\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/sql.py</code> <pre><code>async def find_by_id(self, id: str) -&gt; dict[str, Any] | None:\n    pk = _get_pk_column(self._table)\n    stmt = self._table.select().where(pk == id)\n    async with AsyncSession(self._engine) as session:\n        result = await session.execute(stmt)\n        row = result.mappings().first()\n        return dict(row) if row else None\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.SQLAdapter.find_many","title":"find_many  <code>async</code>","text":"<pre><code>find_many(\n    filters: dict[str, Any] | None = None, limit: int = 100\n) -&gt; list[dict[str, Any]]\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/sql.py</code> <pre><code>async def find_many(self, filters: dict[str, Any] | None = None, limit: int = 100) -&gt; list[dict[str, Any]]:\n    stmt = self._table.select().limit(limit)\n    if filters:\n        for col_name, value in filters.items():\n            if col_name in self._table.c:\n                stmt = stmt.where(self._table.c[col_name] == value)\n    async with AsyncSession(self._engine) as session:\n        result = await session.execute(stmt)\n        return [dict(row) for row in result.mappings().all()]\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.SQLAdapter.create","title":"create  <code>async</code>","text":"<pre><code>create(data: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/sql.py</code> <pre><code>async def create(self, data: dict[str, Any]) -&gt; dict[str, Any]:\n    stmt = self._table.insert().values(**data)\n    async with AsyncSession(self._engine) as session:\n        await session.execute(stmt)\n        await session.commit()\n    return data\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.SQLAdapter.update","title":"update  <code>async</code>","text":"<pre><code>update(\n    id: str, patch: dict[str, Any]\n) -&gt; dict[str, Any] | None\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/sql.py</code> <pre><code>async def update(self, id: str, patch: dict[str, Any]) -&gt; dict[str, Any] | None:\n    pk = _get_pk_column(self._table)\n    stmt = self._table.update().where(pk == id).values(**patch)\n    async with AsyncSession(self._engine) as session:\n        result = await session.execute(stmt)\n        await session.commit()\n        if result.rowcount == 0:\n            return None\n    return await self.find_by_id(id)\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.SQLAdapter.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(id: str) -&gt; bool\n</code></pre> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/sql.py</code> <pre><code>async def delete(self, id: str) -&gt; bool:\n    pk = _get_pk_column(self._table)\n    stmt = self._table.delete().where(pk == id)\n    async with AsyncSession(self._engine) as session:\n        result = await session.execute(stmt)\n        await session.commit()\n        return result.rowcount &gt; 0\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.SQLAdapter.search_semantic","title":"search_semantic  <code>async</code>","text":"<pre><code>search_semantic(\n    query: str, limit: int = 10\n) -&gt; list[dict[str, Any]]\n</code></pre> <p>Semantic search is not natively supported in SQL.</p> <p>For SQL-backed entities, this requires a sidecar vector index. Returns an empty list when no sidecar is configured.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/sql.py</code> <pre><code>async def search_semantic(self, query: str, limit: int = 10) -&gt; list[dict[str, Any]]:\n    \"\"\"Semantic search is not natively supported in SQL.\n\n    For SQL-backed entities, this requires a sidecar vector index.\n    Returns an empty list when no sidecar is configured.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.SQLAdapter.upsert_embedding","title":"upsert_embedding  <code>async</code>","text":"<pre><code>upsert_embedding(id: str, embedding: list[float]) -&gt; None\n</code></pre> <p>Embedding storage is not natively supported in SQL.</p> <p>For SQL-backed entities, embeddings are managed by a sidecar vector adapter. This is a no-op when no sidecar is configured.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/adapters/sql.py</code> <pre><code>async def upsert_embedding(self, id: str, embedding: list[float]) -&gt; None:\n    \"\"\"Embedding storage is not natively supported in SQL.\n\n    For SQL-backed entities, embeddings are managed by a sidecar vector adapter.\n    This is a no-op when no sidecar is configured.\n    \"\"\"\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.ConnectionManager","title":"ConnectionManager","text":"<pre><code>ConnectionManager(\n    profiles: dict[str, ConnectionProfile] | None = None,\n)\n</code></pre> <p>Manages connection pools for all configured engines.</p> <p>Reads connection profiles from <code>.ninjastack/connections.json</code> and lazily creates engine-specific connection objects on first access.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/connections.py</code> <pre><code>def __init__(self, profiles: dict[str, ConnectionProfile] | None = None) -&gt; None:\n    self._profiles: dict[str, ConnectionProfile] = profiles or {}\n    self._sql_engines: dict[str, AsyncEngine] = {}\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.ConnectionManager.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(\n    path: str | Path = \".ninjastack/connections.json\",\n) -&gt; ConnectionManager\n</code></pre> <p>Load connection profiles from a JSON file.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/connections.py</code> <pre><code>@classmethod\ndef from_file(cls, path: str | Path = \".ninjastack/connections.json\") -&gt; ConnectionManager:\n    \"\"\"Load connection profiles from a JSON file.\"\"\"\n    filepath = Path(path)\n    if not filepath.exists():\n        return cls(profiles={})\n    raw = json.loads(filepath.read_text())\n    profiles = {name: ConnectionProfile(**cfg) for name, cfg in raw.items()}\n    return cls(profiles=profiles)\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.ConnectionManager.get_profile","title":"get_profile","text":"<pre><code>get_profile(name: str) -&gt; ConnectionProfile\n</code></pre> <p>Get a connection profile by name.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/connections.py</code> <pre><code>def get_profile(self, name: str) -&gt; ConnectionProfile:\n    \"\"\"Get a connection profile by name.\"\"\"\n    if name not in self._profiles:\n        raise KeyError(f\"Connection profile '{name}' not found. Available: {list(self._profiles.keys())}\")\n    return self._profiles[name]\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.ConnectionManager.get_sql_engine","title":"get_sql_engine","text":"<pre><code>get_sql_engine(\n    profile_name: str = \"default\",\n) -&gt; AsyncEngine\n</code></pre> <p>Get or create an async SQLAlchemy engine for the given profile.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/connections.py</code> <pre><code>def get_sql_engine(self, profile_name: str = \"default\") -&gt; AsyncEngine:\n    \"\"\"Get or create an async SQLAlchemy engine for the given profile.\"\"\"\n    if profile_name not in self._sql_engines:\n        profile = self.get_profile(profile_name)\n        kwargs: dict[str, Any] = {\"echo\": profile.options.get(\"echo\", False)}\n        # pool_size/max_overflow are not supported by SQLite's StaticPool\n        if not profile.url.startswith(\"sqlite\"):\n            kwargs[\"pool_size\"] = profile.options.get(\"pool_size\", 5)\n            kwargs[\"max_overflow\"] = profile.options.get(\"max_overflow\", 10)\n        self._sql_engines[profile_name] = create_async_engine(profile.url, **kwargs)\n    return self._sql_engines[profile_name]\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.ConnectionManager.close_all","title":"close_all  <code>async</code>","text":"<pre><code>close_all() -&gt; None\n</code></pre> <p>Dispose all managed connection pools.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/connections.py</code> <pre><code>async def close_all(self) -&gt; None:\n    \"\"\"Dispose all managed connection pools.\"\"\"\n    for engine in self._sql_engines.values():\n        await engine.dispose()\n    self._sql_engines.clear()\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.ConnectionProfile","title":"ConnectionProfile","text":"<p>               Bases: <code>BaseModel</code></p> <p>A single database connection configuration.</p>"},{"location":"api/persistence/#ninja_persistence.ConnectionProfile.engine","title":"engine  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>engine: str = Field(\n    description=\"Storage engine type: sql, mongo, graph, vector.\"\n)\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.ConnectionProfile.url","title":"url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>url: str = Field(description='Connection URL / DSN.')\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.ConnectionProfile.options","title":"options  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>options: dict[str, Any] = Field(\n    default_factory=dict,\n    description=\"Engine-specific options.\",\n)\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.EmbeddingStrategy","title":"EmbeddingStrategy","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for how to generate embeddings for an entity.</p> <p>Examines the entity schema to determine which fields have embedding configs and produces the text payload to send to the embedding model.</p>"},{"location":"api/persistence/#ninja_persistence.EmbeddingStrategy.model_name","title":"model_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_name: str = Field(\n    default=\"text-embedding-3-small\",\n    description=\"Default embedding model.\",\n)\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.EmbeddingStrategy.dimensions","title":"dimensions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dimensions: int = Field(\n    default=1536,\n    description=\"Default vector dimensionality.\",\n)\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.EmbeddingStrategy.separator","title":"separator  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>separator: str = Field(\n    default=\" \",\n    description=\"Separator when concatenating multiple fields.\",\n)\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.EmbeddingStrategy.get_embeddable_fields","title":"get_embeddable_fields","text":"<pre><code>get_embeddable_fields(\n    entity: EntitySchema,\n) -&gt; list[FieldSchema]\n</code></pre> <p>Return all fields in the entity that have embedding configuration.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/embedding/strategy.py</code> <pre><code>def get_embeddable_fields(self, entity: EntitySchema) -&gt; list[FieldSchema]:\n    \"\"\"Return all fields in the entity that have embedding configuration.\"\"\"\n    return [f for f in entity.fields if f.embedding is not None]\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.EmbeddingStrategy.build_text_for_embedding","title":"build_text_for_embedding","text":"<pre><code>build_text_for_embedding(\n    entity: EntitySchema, record: dict[str, Any]\n) -&gt; str\n</code></pre> <p>Build the text payload to embed from a record's embeddable fields.</p> <p>If no fields have explicit embedding config, falls back to concatenating all string/text fields.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/embedding/strategy.py</code> <pre><code>def build_text_for_embedding(self, entity: EntitySchema, record: dict[str, Any]) -&gt; str:\n    \"\"\"Build the text payload to embed from a record's embeddable fields.\n\n    If no fields have explicit embedding config, falls back to\n    concatenating all string/text fields.\n    \"\"\"\n    embeddable = self.get_embeddable_fields(entity)\n    if embeddable:\n        parts = [str(record.get(f.name, \"\")) for f in embeddable if record.get(f.name)]\n        return self.separator.join(parts)\n\n    # Fallback: concatenate all string-like fields\n    from ninja_core.schema.entity import FieldType\n\n    text_types = {FieldType.STRING, FieldType.TEXT}\n    parts = [\n        str(record.get(f.name, \"\")) for f in entity.fields if f.field_type in text_types and record.get(f.name)\n    ]\n    return self.separator.join(parts)\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.EmbeddingStrategy.get_model_for_field","title":"get_model_for_field","text":"<pre><code>get_model_for_field(field: FieldSchema) -&gt; str\n</code></pre> <p>Return the embedding model to use for a specific field.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/embedding/strategy.py</code> <pre><code>def get_model_for_field(self, field: FieldSchema) -&gt; str:\n    \"\"\"Return the embedding model to use for a specific field.\"\"\"\n    if field.embedding:\n        return field.embedding.model\n    return self.model_name\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.EmbeddingStrategy.get_dimensions_for_field","title":"get_dimensions_for_field","text":"<pre><code>get_dimensions_for_field(field: FieldSchema) -&gt; int\n</code></pre> <p>Return the vector dimensions to use for a specific field.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/embedding/strategy.py</code> <pre><code>def get_dimensions_for_field(self, field: FieldSchema) -&gt; int:\n    \"\"\"Return the vector dimensions to use for a specific field.\"\"\"\n    if field.embedding:\n        return field.embedding.dimensions\n    return self.dimensions\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.Repository","title":"Repository","text":"<p>               Bases: <code>Protocol[T]</code></p> <p>Unified persistence interface for all storage engines.</p> <p>Every adapter (SQL, Mongo, Graph, Vector) implements this protocol so that Data Agents can perform CRUD and semantic search without knowing the backend.</p>"},{"location":"api/persistence/#ninja_persistence.Repository.find_by_id","title":"find_by_id  <code>async</code>","text":"<pre><code>find_by_id(id: str) -&gt; dict[str, Any] | None\n</code></pre> <p>Retrieve a single record by primary key.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/protocols.py</code> <pre><code>async def find_by_id(self, id: str) -&gt; dict[str, Any] | None:\n    \"\"\"Retrieve a single record by primary key.\"\"\"\n    ...\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.Repository.find_many","title":"find_many  <code>async</code>","text":"<pre><code>find_many(\n    filters: dict[str, Any] | None = None, limit: int = 100\n) -&gt; list[dict[str, Any]]\n</code></pre> <p>Retrieve multiple records matching the given filters.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/protocols.py</code> <pre><code>async def find_many(self, filters: dict[str, Any] | None = None, limit: int = 100) -&gt; list[dict[str, Any]]:\n    \"\"\"Retrieve multiple records matching the given filters.\"\"\"\n    ...\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.Repository.create","title":"create  <code>async</code>","text":"<pre><code>create(data: dict[str, Any]) -&gt; dict[str, Any]\n</code></pre> <p>Insert a new record and return the created entity.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/protocols.py</code> <pre><code>async def create(self, data: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Insert a new record and return the created entity.\"\"\"\n    ...\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.Repository.update","title":"update  <code>async</code>","text":"<pre><code>update(\n    id: str, patch: dict[str, Any]\n) -&gt; dict[str, Any] | None\n</code></pre> <p>Apply a partial update to an existing record.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/protocols.py</code> <pre><code>async def update(self, id: str, patch: dict[str, Any]) -&gt; dict[str, Any] | None:\n    \"\"\"Apply a partial update to an existing record.\"\"\"\n    ...\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.Repository.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(id: str) -&gt; bool\n</code></pre> <p>Delete a record by primary key. Returns True if deleted.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/protocols.py</code> <pre><code>async def delete(self, id: str) -&gt; bool:\n    \"\"\"Delete a record by primary key. Returns True if deleted.\"\"\"\n    ...\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.Repository.search_semantic","title":"search_semantic  <code>async</code>","text":"<pre><code>search_semantic(\n    query: str, limit: int = 10\n) -&gt; list[dict[str, Any]]\n</code></pre> <p>Perform semantic (vector similarity) search.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/protocols.py</code> <pre><code>async def search_semantic(self, query: str, limit: int = 10) -&gt; list[dict[str, Any]]:\n    \"\"\"Perform semantic (vector similarity) search.\"\"\"\n    ...\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.Repository.upsert_embedding","title":"upsert_embedding  <code>async</code>","text":"<pre><code>upsert_embedding(id: str, embedding: list[float]) -&gt; None\n</code></pre> <p>Insert or update the embedding vector for a record.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/protocols.py</code> <pre><code>async def upsert_embedding(self, id: str, embedding: list[float]) -&gt; None:\n    \"\"\"Insert or update the embedding vector for a record.\"\"\"\n    ...\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.AdapterRegistry","title":"AdapterRegistry","text":"<pre><code>AdapterRegistry(connection_manager: ConnectionManager)\n</code></pre> <p>Routes entity schemas to the correct persistence adapter.</p> <p>Given an entity's StorageEngine from the ASD, the registry returns a configured Repository instance backed by the appropriate adapter.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/registry.py</code> <pre><code>def __init__(self, connection_manager: ConnectionManager) -&gt; None:\n    self._connection_manager = connection_manager\n    self._overrides: dict[str, Repository[Any]] = {}\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.AdapterRegistry.register","title":"register","text":"<pre><code>register(\n    entity_name: str, repository: Repository[Any]\n) -&gt; None\n</code></pre> <p>Register a custom repository override for an entity.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/registry.py</code> <pre><code>def register(self, entity_name: str, repository: Repository[Any]) -&gt; None:\n    \"\"\"Register a custom repository override for an entity.\"\"\"\n    self._overrides[entity_name] = repository\n</code></pre>"},{"location":"api/persistence/#ninja_persistence.AdapterRegistry.get_repository","title":"get_repository","text":"<pre><code>get_repository(\n    entity: EntitySchema, profile_name: str = \"default\"\n) -&gt; Repository[Any]\n</code></pre> <p>Resolve the correct repository adapter for an entity.</p> <p>Checks overrides first, then falls back to engine-based routing.</p> Source code in <code>libs/ninja-persistence/src/ninja_persistence/registry.py</code> <pre><code>def get_repository(self, entity: EntitySchema, profile_name: str = \"default\") -&gt; Repository[Any]:\n    \"\"\"Resolve the correct repository adapter for an entity.\n\n    Checks overrides first, then falls back to engine-based routing.\n    \"\"\"\n    if entity.name in self._overrides:\n        return self._overrides[entity.name]\n\n    engine = entity.storage_engine\n\n    if engine == StorageEngine.SQL:\n        from ninja_persistence.adapters.sql import SQLAdapter\n\n        sql_engine = self._connection_manager.get_sql_engine(profile_name)\n        return SQLAdapter(engine=sql_engine, entity=entity)\n\n    if engine == StorageEngine.MONGO:\n        from ninja_persistence.adapters.mongo import MongoAdapter\n\n        return MongoAdapter(entity=entity)\n\n    if engine == StorageEngine.GRAPH:\n        from ninja_persistence.adapters.graph import GraphAdapter\n\n        return GraphAdapter(entity=entity)\n\n    if engine == StorageEngine.VECTOR:\n        from ninja_persistence.adapters.chroma import ChromaVectorAdapter\n\n        return ChromaVectorAdapter(entity=entity)\n\n    raise ValueError(f\"Unsupported storage engine: {engine}\")\n</code></pre>"},{"location":"architecture/","title":"Architecture","text":"<p>NinjaStack is a modular monorepo of 15 focused Python packages. Each package has a single responsibility and clear API boundaries.</p>"},{"location":"architecture/#system-overview","title":"System Overview","text":"<pre><code>flowchart TB\n    subgraph Input\n        DB[(Existing DB)]\n        CHAT[Conversational Setup]\n    end\n\n    subgraph Schema\n        INTROSPECT[ninja-introspect]\n        ASSISTANT[ninja-setup-assistant]\n        ASD[Agentic Schema Definition]\n    end\n\n    subgraph Generation\n        CODEGEN[ninja-codegen]\n        MODELS[Pydantic Models]\n        AGENTS[ADK Agents]\n        GQL[GraphQL Types]\n    end\n\n    subgraph Runtime\n        AUTH[ninja-auth]\n        COORD[Coordinator Agent]\n        DOMAIN[Domain Agents]\n        DATA[Data Agents]\n        PERSIST[ninja-persistence]\n    end\n\n    DB --&gt; INTROSPECT --&gt; ASD\n    CHAT --&gt; ASSISTANT --&gt; ASD\n    ASD --&gt; CODEGEN\n    CODEGEN --&gt; MODELS\n    CODEGEN --&gt; AGENTS\n    CODEGEN --&gt; GQL\n    AGENTS --&gt; COORD --&gt; DOMAIN --&gt; DATA --&gt; PERSIST\n    AUTH --&gt; COORD</code></pre>"},{"location":"architecture/#package-map","title":"Package Map","text":"Package Layer Purpose <code>ninja-core</code> Schema ASD models (entity, domain, relationship, agent config) <code>ninja-introspect</code> Input Database schema discovery <code>ninja-codegen</code> Generation Jinja2 template engine for code generation <code>ninja-agents</code> Runtime ADK agent classes (DataAgent, DomainAgent, Coordinator) <code>ninja-auth</code> Runtime Auth gateway, strategies, RBAC <code>ninja-gql</code> Runtime Strawberry GraphQL layer generation <code>ninja-persistence</code> Runtime Unified polyglot persistence <code>ninja-boundary</code> Runtime Data tolerance and coercion <code>ninja-graph</code> Runtime Graph-RAG bootstrapper <code>ninja-models</code> Generation Pydantic model generation <code>ninja-deploy</code> Deploy Helm/K8s manifest generation <code>ninja-ui</code> Generation CRUD viewer and chat UI generation <code>ninja-cli</code> CLI <code>ninjastack</code> command-line interface <code>ninja-api</code> App FastAPI server <code>ninja-setup-assistant</code> App Gemini-powered conversational setup"},{"location":"architecture/#deep-dives","title":"Deep Dives","text":"<ul> <li>Agent Hierarchy \u2014 Three-tier agent architecture</li> <li>Agentic Schema Definition \u2014 The schema language</li> <li>Code Generation Pipeline \u2014 How templates produce code</li> <li>Auth &amp; RBAC \u2014 Authentication and permission enforcement</li> <li>Persistence Layer \u2014 Polyglot database abstraction</li> </ul>"},{"location":"architecture/agent-hierarchy/","title":"Agent Hierarchy","text":"<p>NinjaStack's agent architecture follows a strict three-tier hierarchy with explicit ownership boundaries.</p>"},{"location":"architecture/agent-hierarchy/#overview","title":"Overview","text":"<pre><code>graph TD\n    C[\ud83c\udfaf Coordinator Agent&lt;br/&gt;LlmAgent \u00b7 gemini-2.5-pro]\n    C --&gt; D1[\ud83d\udcda Catalog Domain Agent&lt;br/&gt;LlmAgent \u00b7 gemini-2.5-flash]\n    C --&gt; D2[\ud83d\uded2 Commerce Domain Agent&lt;br/&gt;LlmAgent \u00b7 gemini-2.5-pro]\n    D1 --&gt; DA1[\ud83d\udcd6 Book Data Agent&lt;br/&gt;BaseAgent \u00b7 No LLM]\n    D1 --&gt; DA2[\u2b50 Review Data Agent&lt;br/&gt;BaseAgent \u00b7 No LLM]\n    D2 --&gt; DA3[\ud83d\udc64 Customer Data Agent&lt;br/&gt;BaseAgent \u00b7 No LLM]\n    D2 --&gt; DA4[\ud83d\udce6 Order Data Agent&lt;br/&gt;BaseAgent \u00b7 No LLM]\n\n    style C fill:#166534,color:#fff\n    style D1 fill:#1e3a5f,color:#fff\n    style D2 fill:#1e3a5f,color:#fff\n    style DA1 fill:#3d3d00,color:#fff\n    style DA2 fill:#3d3d00,color:#fff\n    style DA3 fill:#3d3d00,color:#fff\n    style DA4 fill:#3d3d00,color:#fff</code></pre>"},{"location":"architecture/agent-hierarchy/#tier-1-data-agents","title":"Tier 1: Data Agents","text":"<p>Data agents are the workhorses. They extend ADK's <code>BaseAgent</code> and execute deterministic CRUD operations without any LLM calls.</p> <pre><code>from ninja_agents.base import DataAgent\n\nbook_agent = DataAgent(entity=book_schema)\nbook_agent.execute(\"book_get\", id=\"abc-123\")  # Instant, deterministic\n</code></pre> <p>Properties:</p> <ul> <li>One agent per entity</li> <li>6 auto-generated tools: <code>get</code>, <code>list</code>, <code>create</code>, <code>update</code>, <code>delete</code>, <code>search_semantic</code></li> <li>Tool scoping: can only access its own entity's tools</li> <li><code>uses_llm = False</code> (reasoning level NONE)</li> <li>Implements <code>_run_async_impl</code> for ADK Runner compatibility</li> </ul>"},{"location":"architecture/agent-hierarchy/#tier-2-domain-agents","title":"Tier 2: Domain Agents","text":"<p>Domain agents own a business domain (logical grouping of entities). They wrap ADK's <code>LlmAgent</code> and use Gemini for reasoning about cross-entity operations within their domain.</p> <pre><code>from ninja_agents.base import DomainAgent\n\ncatalog = DomainAgent(\n    domain=catalog_domain,\n    data_agents=[book_agent, review_agent],\n)\ncatalog.delegate(\"Book\", \"book_get\", id=\"abc-123\")\n</code></pre> <p>Properties:</p> <ul> <li>One agent per domain</li> <li>Sub-agents are the domain's data agents</li> <li>LLM-powered intent classification within the domain</li> <li>Configurable reasoning level and temperature</li> <li>Cannot access entities outside its domain</li> </ul>"},{"location":"architecture/agent-hierarchy/#tier-3-coordinator-agent","title":"Tier 3: Coordinator Agent","text":"<p>The coordinator is the top-level router. It classifies user intent and delegates to the appropriate domain agent(s).</p> <pre><code>from ninja_agents.base import CoordinatorAgent\n\ncoordinator = CoordinatorAgent(domain_agents=[catalog, commerce])\ncoordinator.route(\"Find sci-fi books under $20\", target_domains=[\"Catalog\"])\n</code></pre> <p>Properties:</p> <ul> <li>Single instance per application</li> <li>Sub-agents are domain agents</li> <li>Uses highest reasoning level (gemini-2.5-pro)</li> <li>Can fan out to multiple domains for cross-domain queries</li> <li>Never executes tools directly</li> </ul>"},{"location":"architecture/agent-hierarchy/#why-three-tiers","title":"Why Three Tiers?","text":"Concern Solution Cost Data agents are free (no LLM). Only domain/coordinator agents burn tokens. Latency CRUD operations are instant. LLM only used for intent classification. Scope Each agent has a bounded tool set. No agent sees everything. Testability Data agents are fully deterministic and testable without mocks. Security RBAC enforcement at each tier. Unauthorized tools never execute."},{"location":"architecture/asd/","title":"Agentic Schema Definition (ASD)","text":"<p>The ASD is NinjaStack's schema language \u2014 a typed, composable definition of your entire data model, agent configuration, and domain boundaries.</p>"},{"location":"architecture/asd/#schema-structure","title":"Schema Structure","text":"<pre><code>classDiagram\n    class AgenticSchema {\n        +str project_name\n        +list~EntitySchema~ entities\n        +list~RelationshipSchema~ relationships\n        +list~DomainSchema~ domains\n    }\n    class EntitySchema {\n        +str name\n        +StorageEngine storage_engine\n        +list~FieldSchema~ fields\n    }\n    class FieldSchema {\n        +str name\n        +FieldType field_type\n        +bool primary_key\n        +bool indexed\n        +FieldConstraint constraints\n        +EmbeddingConfig embedding\n    }\n    class DomainSchema {\n        +str name\n        +list~str~ entities\n        +AgentConfig agent_config\n    }\n    class RelationshipSchema {\n        +str name\n        +str source_entity\n        +str target_entity\n        +RelationshipType type\n        +Cardinality cardinality\n    }\n    AgenticSchema --&gt; EntitySchema\n    AgenticSchema --&gt; RelationshipSchema\n    AgenticSchema --&gt; DomainSchema\n    EntitySchema --&gt; FieldSchema</code></pre>"},{"location":"architecture/asd/#entities","title":"Entities","text":"<p>Entities map to tables (SQL), collections (Mongo), nodes (Graph), or vector stores.</p> <pre><code>from ninja_core.schema.entity import EntitySchema, FieldSchema, FieldType, StorageEngine\n\nbook = EntitySchema(\n    name=\"Book\",\n    storage_engine=StorageEngine.SQL,\n    fields=[\n        FieldSchema(name=\"id\", field_type=FieldType.UUID, primary_key=True),\n        FieldSchema(name=\"title\", field_type=FieldType.STRING, indexed=True,\n                    constraints=FieldConstraint(min_length=1, max_length=500)),\n        FieldSchema(name=\"price\", field_type=FieldType.FLOAT,\n                    constraints=FieldConstraint(ge=0.0)),\n    ],\n)\n</code></pre>"},{"location":"architecture/asd/#field-types","title":"Field Types","text":"Type Python Mapping Description <code>STRING</code> <code>str</code> Short text <code>TEXT</code> <code>str</code> Long text (supports embedding) <code>INTEGER</code> <code>int</code> Whole numbers <code>FLOAT</code> <code>float</code> Decimal numbers <code>BOOLEAN</code> <code>bool</code> True/False <code>DATETIME</code> <code>datetime</code> Timestamp <code>DATE</code> <code>date</code> Date only <code>UUID</code> <code>UUID</code> Unique identifier <code>JSON</code> <code>dict</code> Arbitrary JSON <code>ARRAY</code> <code>list</code> Lists <code>BINARY</code> <code>bytes</code> Binary data <code>ENUM</code> <code>str</code> Constrained values"},{"location":"architecture/asd/#embedding-config","title":"Embedding Config","text":"<p>Fields can be configured for vector embedding:</p> <pre><code>FieldSchema(\n    name=\"text\",\n    field_type=FieldType.TEXT,\n    embedding=EmbeddingConfig(\n        model=\"text-embedding-3-small\",\n        dimensions=1536,\n        chunk_strategy=\"paragraph\",\n    ),\n)\n</code></pre>"},{"location":"architecture/asd/#relationships","title":"Relationships","text":"<p>Three types of relationships between entities:</p> <pre><code>from ninja_core.schema.relationship import RelationshipSchema, RelationshipType, Cardinality\n\n# Hard FK relationship\nRelationshipSchema(\n    name=\"order_customer\",\n    source_entity=\"Order\",\n    target_entity=\"Customer\",\n    relationship_type=RelationshipType.HARD,\n    cardinality=Cardinality.MANY_TO_ONE,\n    source_field=\"customer_id\",\n    target_field=\"id\",\n)\n\n# Semantic similarity\nRelationshipSchema(\n    name=\"similar_reviews\",\n    source_entity=\"Book\",\n    target_entity=\"Review\",\n    relationship_type=RelationshipType.SOFT,\n    cardinality=Cardinality.MANY_TO_MANY,\n)\n\n# Graph edge\nRelationshipSchema(\n    name=\"authored_by\",\n    source_entity=\"Book\",\n    target_entity=\"Author\",\n    relationship_type=RelationshipType.GRAPH,\n    cardinality=Cardinality.MANY_TO_ONE,\n    edge_label=\"AUTHORED_BY\",\n)\n</code></pre>"},{"location":"architecture/asd/#domains","title":"Domains","text":"<p>Domains group entities under a single expert agent:</p> <pre><code>from ninja_core.schema.domain import DomainSchema\nfrom ninja_core.schema.agent import AgentConfig, ReasoningLevel\n\ncatalog = DomainSchema(\n    name=\"Catalog\",\n    entities=[\"Book\", \"Review\"],\n    agent_config=AgentConfig(\n        model_name=\"gemini-2.5-flash\",\n        reasoning_level=ReasoningLevel.MEDIUM,\n        temperature=0.7,\n    ),\n)\n</code></pre>"},{"location":"architecture/asd/#serialization","title":"Serialization","text":"<p>The full schema serializes to <code>.ninjastack/schema.json</code>:</p> <pre><code>from ninja_core.serialization.io import save_schema, load_schema\n\nsave_schema(schema, \".ninjastack/schema.json\")\nloaded = load_schema(\".ninjastack/schema.json\")\n</code></pre>"},{"location":"architecture/auth-rbac/","title":"Authentication &amp; RBAC","text":"<p>NinjaStack provides pluggable authentication and declarative role-based access control.</p>"},{"location":"architecture/auth-rbac/#auth-gateway","title":"Auth Gateway","text":"<p>The auth gateway is a FastAPI middleware that authenticates requests and injects user context.</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Gateway\n    participant Strategy\n    participant RBAC\n    participant Agent\n\n    Client-&gt;&gt;Gateway: Request + Credentials\n    Gateway-&gt;&gt;Strategy: Authenticate\n    Strategy--&gt;&gt;Gateway: UserContext\n    Gateway-&gt;&gt;RBAC: Enrich permissions\n    RBAC--&gt;&gt;Gateway: UserContext + permissions\n    Gateway-&gt;&gt;Agent: Forward with context\n    Agent-&gt;&gt;Agent: Check permissions before tool execution</code></pre>"},{"location":"architecture/auth-rbac/#auth-strategies","title":"Auth Strategies","text":"Strategy Use Case Credentials OAuth2 User login (Google, GitHub) Authorization code flow Bearer Token-based API access JWT in <code>Authorization</code> header API Key Service-to-service Key in header or query param Identity Built-in accounts Email + password \u2192 JWT"},{"location":"architecture/auth-rbac/#example-identity-strategy","title":"Example: Identity Strategy","text":"<pre><code>from ninja_auth.config import IdentityConfig\nfrom ninja_auth.strategies.identity import IdentityStrategy\n\nidentity = IdentityStrategy(config=IdentityConfig(\n    token_secret=\"your-32-byte-secret-key-here!!!\"\n))\n\n# Register\nuser = identity.register(email=\"alice@example.com\", password=\"s3cur3!\", roles=[\"customer\"])\n\n# Login\nuser = identity.login(email=\"alice@example.com\", password=\"s3cur3!\")\n\n# Issue token\ntoken = identity.issue_token(user)\n\n# Validate\ncontext = identity.validate_token(token)\n</code></pre>"},{"location":"architecture/auth-rbac/#rbac","title":"RBAC","text":"<p>Permissions use a string format: <code>action:scope</code></p>"},{"location":"architecture/auth-rbac/#permission-format","title":"Permission Format","text":"<pre><code>action:scope\n\nWhere:\n  action = read | write | delete | *\n  scope  = DomainName | DomainName.EntityName | *\n</code></pre>"},{"location":"architecture/auth-rbac/#examples","title":"Examples","text":"Permission Meaning <code>read:Catalog</code> Read any entity in the Catalog domain <code>write:Catalog.Review</code> Write only the Review entity <code>delete:*</code> Delete anything <code>*:*</code> Superuser \u2014 all actions, all scopes"},{"location":"architecture/auth-rbac/#built-in-roles","title":"Built-in Roles","text":"Role Permissions <code>admin</code> <code>*:*</code> <code>editor</code> <code>read:*</code>, <code>write:*</code> <code>viewer</code> <code>read:*</code>"},{"location":"architecture/auth-rbac/#custom-roles","title":"Custom Roles","text":"<pre><code>from ninja_auth.rbac import RBACConfig, RBACPolicy, RoleDefinition\n\npolicy = RBACPolicy(config=RBACConfig(roles={\n    \"customer\": RoleDefinition(permissions=[\n        \"read:Catalog\",\n        \"write:Catalog.Review\",\n        \"read:Commerce.Order\",\n    ]),\n}))\n\n# Check\nperms = policy.permissions_for_roles([\"customer\"])\npolicy.is_allowed(perms, \"write\", \"Catalog\", \"Review\")  # True\npolicy.is_allowed(perms, \"write\", \"Catalog\", \"Book\")     # False\n\n# Enforce (raises PermissionError)\npolicy.check(perms, \"delete\", \"Catalog\", \"Book\")  # PermissionError!\n</code></pre>"},{"location":"architecture/auth-rbac/#agent-integration","title":"Agent Integration","text":"<p>Permission checks happen before tool execution:</p> <pre><code>def protected_execute(agent, tool_name, user_roles, domain):\n    action = \"read\" if tool_name.endswith((\"_get\", \"_list\")) else \"write\"\n    perms = policy.permissions_for_roles(user_roles)\n\n    if not policy.is_allowed(perms, action, domain, agent.entity.name):\n        raise PermissionError(f\"Denied: {action}:{domain}.{agent.entity.name}\")\n\n    return agent.execute(tool_name)\n</code></pre>"},{"location":"architecture/codegen/","title":"Code Generation Pipeline","text":"<p>NinjaStack's code generation engine transforms an Agentic Schema Definition into runnable Python code.</p>"},{"location":"architecture/codegen/#pipeline","title":"Pipeline","text":"<pre><code>flowchart LR\n    ASD[schema.json] --&gt; Engine[CodeGen Engine]\n    Engine --&gt; Models[Pydantic Models]\n    Engine --&gt; Agents[ADK Agents]\n    Engine --&gt; GQL[GraphQL Types]\n    Engine --&gt; App[FastAPI Shell]</code></pre>"},{"location":"architecture/codegen/#how-it-works","title":"How It Works","text":"<ol> <li>Load the ASD from <code>.ninjastack/schema.json</code></li> <li>Run Jinja2 templates for each generator</li> <li>Write generated files to <code>_generated/</code> directory</li> <li>Diff against existing files (only write if changed)</li> </ol> <pre><code>from ninja_codegen.generators.models import generate_models\nfrom ninja_codegen.generators.agents import generate_agents\nfrom ninja_codegen.generators.graphql import generate_graphql\n\n# Generate everything\nmodel_paths = generate_models(schema.entities, output_dir)\nagent_paths = generate_agents(schema.entities, schema.domains, output_dir)\ngql_paths = generate_graphql(schema.entities, output_dir)\n</code></pre>"},{"location":"architecture/codegen/#generated-output","title":"Generated Output","text":""},{"location":"architecture/codegen/#models-_generatedmodels","title":"Models (<code>_generated/models/</code>)","text":"<p>One Pydantic model per entity with typed fields:</p> <pre><code># AUTO-GENERATED by ninja-codegen \u2014 DO NOT EDIT\nclass Book(BaseModel):\n    id: UUID\n    title: str\n    author: str\n    price: float\n    genre: str\n    published_date: date | None = None\n    in_stock: bool = True\n</code></pre>"},{"location":"architecture/codegen/#agents-_generatedagents","title":"Agents (<code>_generated/agents/</code>)","text":"<ul> <li>Data agents \u2014 <code>DataAgent(entity=ENTITY)</code> per entity</li> <li>Domain agents \u2014 <code>DomainAgent(domain=DOMAIN, data_agents=[...])</code> per domain</li> <li>Coordinator \u2014 <code>CoordinatorAgent(domain_agents=[...])</code> top-level</li> </ul>"},{"location":"architecture/codegen/#graphql-_generatedgraphql","title":"GraphQL (<code>_generated/graphql/</code>)","text":"<p>Strawberry types, inputs, queries, and mutations:</p> <pre><code># AUTO-GENERATED by ninja-codegen \u2014 DO NOT EDIT\n@strawberry.type\nclass BookType:\n    id: UUID\n    title: str\n    author: str\n    price: float\n\n@strawberry.type\nclass BookQuery:\n    @strawberry.field\n    def book(self, id: UUID) -&gt; BookType: ...\n\n    @strawberry.field\n    def books(self) -&gt; list[BookType]: ...\n</code></pre>"},{"location":"architecture/codegen/#templates","title":"Templates","text":"<p>Templates are Jinja2 files in <code>libs/ninja-codegen/src/ninja_codegen/templates/</code>:</p> Template Output <code>model.py.j2</code> Pydantic model class <code>data_agent.py.j2</code> ADK DataAgent instantiation <code>domain_agent.py.j2</code> ADK DomainAgent instantiation <code>coordinator_agent.py.j2</code> CoordinatorAgent wiring <code>gql_type.py.j2</code> Strawberry GraphQL type + resolvers <code>app_shell.py.j2</code> FastAPI application shell"},{"location":"architecture/codegen/#idempotent-generation","title":"Idempotent Generation","text":"<p>Running <code>ninjastack sync</code> multiple times produces identical output. The differ engine compares generated content against existing files and only writes when content has changed.</p>"},{"location":"architecture/persistence/","title":"Persistence Layer","text":"<p>NinjaStack's unified persistence layer routes operations to the correct database backend based on each entity's declared storage engine.</p>"},{"location":"architecture/persistence/#polyglot-architecture","title":"Polyglot Architecture","text":"<pre><code>flowchart TD\n    DA[Data Agent] --&gt; PL[Persistence Layer]\n    PL --&gt; SQL[(PostgreSQL / SQLite)]\n    PL --&gt; NOSQL[(MongoDB)]\n    PL --&gt; GRAPH[(Neo4j)]\n    PL --&gt; VECTOR[(ChromaDB / Pinecone)]</code></pre>"},{"location":"architecture/persistence/#storage-engines","title":"Storage Engines","text":"<p>Each entity declares its storage engine in the ASD:</p> <pre><code>EntitySchema(\n    name=\"Book\",\n    storage_engine=StorageEngine.SQL,  # or MONGO, GRAPH, VECTOR\n    fields=[...],\n)\n</code></pre> Engine Backend Best For <code>SQL</code> PostgreSQL, SQLite Structured relational data, transactions <code>MONGO</code> MongoDB Document-oriented, flexible schemas <code>GRAPH</code> Neo4j Relationship-heavy data, traversals <code>VECTOR</code> ChromaDB, Pinecone Semantic search, embeddings"},{"location":"architecture/persistence/#mixed-storage","title":"Mixed Storage","text":"<p>A single project can use multiple engines. For example:</p> <ul> <li><code>Customer</code>, <code>Order</code> \u2192 SQL (transactional data)</li> <li><code>Review</code> \u2192 SQL + Vector (text stored in SQL, embeddings in ChromaDB)</li> <li><code>AuthorNetwork</code> \u2192 Graph (relationship traversals in Neo4j)</li> </ul> <p>The persistence layer handles routing transparently. Data agents don't need to know which backend is in use.</p>"},{"location":"architecture/persistence/#configuration","title":"Configuration","text":"<p>Database connections are configured in <code>.ninjastack/persistence.json</code>:</p> <pre><code>{\n  \"engines\": {\n    \"sql\": {\n      \"url\": \"postgresql://localhost/myapp\",\n      \"pool_size\": 10\n    },\n    \"mongo\": {\n      \"url\": \"mongodb://localhost:27017/myapp\"\n    },\n    \"graph\": {\n      \"url\": \"neo4j://localhost:7687\",\n      \"auth\": {\"user\": \"neo4j\", \"password\": \"...\"}\n    },\n    \"vector\": {\n      \"provider\": \"chroma\",\n      \"path\": \".ninjastack/chroma_db\"\n    }\n  }\n}\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>Walk through a complete Online Bookstore to learn every layer of NinjaStack.</p>"},{"location":"examples/#the-bookstore","title":"The Bookstore","text":"<p>A simple bookstore with Books, Customers, Orders, and Reviews \u2014 enough to demonstrate the full stack.</p> # Example What You'll Learn 1 Schema Definition Define entities, relationships, domains 2 Code Generation Generate models, agents, GraphQL from schema 3 Data Agents Deterministic CRUD, tool scoping, tracing 4 Domain Agents LLM-powered orchestration, delegation 5 Auth &amp; RBAC Identity, tokens, role-based permissions 6 End-to-End Full pipeline: schema \u2192 agents \u2192 auth \u2192 query"},{"location":"examples/#running-the-examples","title":"Running the Examples","text":"<pre><code>cd agentic-backend\nPYTHONPATH=examples/bookstore uv run python examples/bookstore/01_schema_definition.py\n</code></pre> <p>All examples run without API keys (deterministic mode).</p>"},{"location":"examples/01-schema/","title":"Example 1: Schema Definition","text":"<p>Define your data model using the Agentic Schema Definition.</p> examples/bookstore/01_schema_definition.py<pre><code>#!/usr/bin/env python3\n\"\"\"Example 1: Schema Definition \u2014 Defining your data model with the ASD.\n\nDemonstrates:\n- Creating entities with typed fields, constraints, and storage engines\n- Defining relationships between entities (hard FK, soft semantic, graph)\n- Grouping entities into domains with agent configuration\n- Assembling the full AgenticSchema (project-level container)\n- Serializing to .ninjastack/schema.json\n\"\"\"\n\nfrom ninja_core.schema.agent import AgentConfig, ReasoningLevel\nfrom ninja_core.schema.domain import DomainSchema\nfrom ninja_core.schema.entity import (\n    EmbeddingConfig,\n    EntitySchema,\n    FieldConstraint,\n    FieldSchema,\n    FieldType,\n    StorageEngine,\n)\nfrom ninja_core.schema.project import AgenticSchema\nfrom ninja_core.schema.relationship import Cardinality, RelationshipSchema, RelationshipType\nfrom ninja_core.serialization.io import save_schema\n\n# ---------------------------------------------------------------------------\n# 1. Define Entities\n# ---------------------------------------------------------------------------\n\nbook = EntitySchema(\n    name=\"Book\",\n    storage_engine=StorageEngine.SQL,\n    description=\"A book in the catalog.\",\n    fields=[\n        FieldSchema(name=\"id\", field_type=FieldType.UUID, primary_key=True),\n        FieldSchema(name=\"title\", field_type=FieldType.STRING, indexed=True,\n                    constraints=FieldConstraint(min_length=1, max_length=500)),\n        FieldSchema(name=\"author\", field_type=FieldType.STRING, indexed=True),\n        FieldSchema(name=\"isbn\", field_type=FieldType.STRING, unique=True,\n                    constraints=FieldConstraint(pattern=r\"^\\d{13}$\")),\n        FieldSchema(name=\"price\", field_type=FieldType.FLOAT,\n                    constraints=FieldConstraint(ge=0.0)),\n        FieldSchema(name=\"genre\", field_type=FieldType.ENUM,\n                    constraints=FieldConstraint(\n                        enum_values=[\"fiction\", \"non-fiction\", \"sci-fi\", \"mystery\", \"biography\"]\n                    )),\n        FieldSchema(name=\"published_date\", field_type=FieldType.DATE, nullable=True),\n        FieldSchema(name=\"in_stock\", field_type=FieldType.BOOLEAN, default=True),\n    ],\n)\n\ncustomer = EntitySchema(\n    name=\"Customer\",\n    storage_engine=StorageEngine.SQL,\n    description=\"A registered bookstore customer.\",\n    fields=[\n        FieldSchema(name=\"id\", field_type=FieldType.UUID, primary_key=True),\n        FieldSchema(name=\"email\", field_type=FieldType.STRING, unique=True),\n        FieldSchema(name=\"name\", field_type=FieldType.STRING),\n        FieldSchema(name=\"joined_at\", field_type=FieldType.DATETIME),\n    ],\n)\n\norder = EntitySchema(\n    name=\"Order\",\n    storage_engine=StorageEngine.SQL,\n    description=\"A purchase order linking a customer to books.\",\n    fields=[\n        FieldSchema(name=\"id\", field_type=FieldType.UUID, primary_key=True),\n        FieldSchema(name=\"customer_id\", field_type=FieldType.UUID, indexed=True),\n        FieldSchema(name=\"total\", field_type=FieldType.FLOAT,\n                    constraints=FieldConstraint(ge=0.0)),\n        FieldSchema(name=\"status\", field_type=FieldType.ENUM,\n                    constraints=FieldConstraint(\n                        enum_values=[\"pending\", \"confirmed\", \"shipped\", \"delivered\", \"cancelled\"]\n                    )),\n        FieldSchema(name=\"created_at\", field_type=FieldType.DATETIME),\n    ],\n)\n\nreview = EntitySchema(\n    name=\"Review\",\n    storage_engine=StorageEngine.SQL,\n    description=\"A customer review of a book. Text is semantic-searchable.\",\n    fields=[\n        FieldSchema(name=\"id\", field_type=FieldType.UUID, primary_key=True),\n        FieldSchema(name=\"book_id\", field_type=FieldType.UUID, indexed=True),\n        FieldSchema(name=\"customer_id\", field_type=FieldType.UUID, indexed=True),\n        FieldSchema(name=\"rating\", field_type=FieldType.INTEGER,\n                    constraints=FieldConstraint(ge=1, le=5)),\n        FieldSchema(name=\"text\", field_type=FieldType.TEXT,\n                    description=\"Free-text review body \u2014 vectorized for semantic search.\",\n                    embedding=EmbeddingConfig(\n                        model=\"text-embedding-3-small\",\n                        dimensions=1536,\n                        chunk_strategy=\"paragraph\",\n                    )),\n        FieldSchema(name=\"created_at\", field_type=FieldType.DATETIME),\n    ],\n)\n\nprint(\"\u2705 Entities defined:\")\nfor e in [book, customer, order, review]:\n    print(f\"   {e.name} ({e.storage_engine.value}) \u2014 {len(e.fields)} fields\")\n\n# ---------------------------------------------------------------------------\n# 2. Define Relationships\n# ---------------------------------------------------------------------------\n\nrelationships = [\n    # Hard FK: Order \u2192 Customer\n    RelationshipSchema(\n        name=\"order_customer\",\n        source_entity=\"Order\",\n        target_entity=\"Customer\",\n        relationship_type=RelationshipType.HARD,\n        cardinality=Cardinality.MANY_TO_ONE,\n        source_field=\"customer_id\",\n        target_field=\"id\",\n        description=\"Each order belongs to one customer.\",\n    ),\n    # Hard FK: Review \u2192 Book\n    RelationshipSchema(\n        name=\"review_book\",\n        source_entity=\"Review\",\n        target_entity=\"Book\",\n        relationship_type=RelationshipType.HARD,\n        cardinality=Cardinality.MANY_TO_ONE,\n        source_field=\"book_id\",\n        target_field=\"id\",\n        description=\"Each review is about one book.\",\n    ),\n    # Hard FK: Review \u2192 Customer\n    RelationshipSchema(\n        name=\"review_customer\",\n        source_entity=\"Review\",\n        target_entity=\"Customer\",\n        relationship_type=RelationshipType.HARD,\n        cardinality=Cardinality.MANY_TO_ONE,\n        source_field=\"customer_id\",\n        target_field=\"id\",\n        description=\"Each review is written by one customer.\",\n    ),\n    # Soft/Semantic: Book \u2194 Review (vector similarity for recommendations)\n    RelationshipSchema(\n        name=\"book_similar_reviews\",\n        source_entity=\"Book\",\n        target_entity=\"Review\",\n        relationship_type=RelationshipType.SOFT,\n        cardinality=Cardinality.MANY_TO_MANY,\n        description=\"Semantic similarity between book descriptions and review text.\",\n    ),\n]\n\nprint(f\"\\n\u2705 Relationships defined: {len(relationships)}\")\nfor r in relationships:\n    print(f\"   {r.name}: {r.source_entity} \u2192 {r.target_entity} ({r.relationship_type.value}, {r.cardinality.value})\")\n\n# ---------------------------------------------------------------------------\n# 3. Define Domains\n# ---------------------------------------------------------------------------\n\ncatalog_domain = DomainSchema(\n    name=\"Catalog\",\n    entities=[\"Book\", \"Review\"],\n    description=\"Book catalog and reviews \u2014 handles browsing, search, and recommendations.\",\n    agent_config=AgentConfig(\n        model_provider=\"gemini\",\n        model_name=\"gemini-2.5-flash\",\n        reasoning_level=ReasoningLevel.MEDIUM,\n        system_prompt=\"You are the Catalog domain agent. Help users find books, browse reviews, and get recommendations.\",\n    ),\n)\n\ncommerce_domain = DomainSchema(\n    name=\"Commerce\",\n    entities=[\"Customer\", \"Order\"],\n    description=\"Customer management and order processing.\",\n    agent_config=AgentConfig(\n        model_provider=\"gemini\",\n        model_name=\"gemini-2.5-pro\",\n        reasoning_level=ReasoningLevel.HIGH,\n        temperature=0.3,  # Lower temp for transactional operations\n        system_prompt=\"You are the Commerce domain agent. Handle customer accounts and order operations accurately.\",\n    ),\n)\n\nprint(f\"\\n\u2705 Domains defined: {len([catalog_domain, commerce_domain])}\")\nfor d in [catalog_domain, commerce_domain]:\n    print(f\"   {d.name}: entities={d.entities}, model={d.agent_config.model_name}, reasoning={d.agent_config.reasoning_level.value}\")\n\n# ---------------------------------------------------------------------------\n# 4. Assemble the Full Schema\n# ---------------------------------------------------------------------------\n\nschema = AgenticSchema(\n    project_name=\"Bookstore\",\n    description=\"Online bookstore with catalog, commerce, and semantic review search.\",\n    entities=[book, customer, order, review],\n    relationships=relationships,\n    domains=[catalog_domain, commerce_domain],\n)\n\nprint(f\"\\n\u2705 AgenticSchema assembled: '{schema.project_name}'\")\nprint(f\"   {len(schema.entities)} entities, {len(schema.relationships)} relationships, {len(schema.domains)} domains\")\n\n# ---------------------------------------------------------------------------\n# 5. Serialize to JSON (what .ninjastack/schema.json looks like)\n# ---------------------------------------------------------------------------\n\njson_output = schema.model_dump_json(indent=2)\nprint(f\"\\n\ud83d\udcc4 Serialized schema ({len(json_output)} bytes):\")\nprint(json_output[:500] + \"...\" if len(json_output) &gt; 500 else json_output)\n\n# You can also save to disk:\n# save_schema(schema, \".ninjastack/schema.json\")\n</code></pre>"},{"location":"examples/01-schema/#what-this-shows","title":"What This Shows","text":"<ul> <li>Entities with typed fields, constraints, and storage engines</li> <li>Relationships \u2014 hard (FK), soft (semantic), graph</li> <li>Domains \u2014 logical groupings with agent config</li> <li>AgenticSchema \u2014 the full project container</li> <li>Serialization to JSON</li> </ul>"},{"location":"examples/01-schema/#run-it","title":"Run It","text":"<pre><code>PYTHONPATH=examples/bookstore uv run python examples/bookstore/01_schema_definition.py\n</code></pre>"},{"location":"examples/02-codegen/","title":"Example 2: Code Generation","text":"<p>Generate Pydantic models, ADK agents, and GraphQL types from your schema.</p> examples/bookstore/02_code_generation.py<pre><code>#!/usr/bin/env python3\n\"\"\"Example 2: Code Generation \u2014 Generate models, agents, and GraphQL from a schema.\n\nDemonstrates:\n- Running the codegen engine against an AgenticSchema\n- Generated Pydantic models (one per entity)\n- Generated ADK DataAgent/DomainAgent/CoordinatorAgent stubs\n- Generated Strawberry GraphQL types, queries, and mutations\n- Inspecting generated file contents\n\"\"\"\n\nimport tempfile\nfrom pathlib import Path\n\nfrom ninja_codegen.generators.agents import generate_agents\nfrom ninja_codegen.generators.graphql import generate_graphql\nfrom ninja_codegen.generators.models import generate_models\n\n# Re-use the bookstore schema from Example 1\nfrom _bookstore_schema import SCHEMA\n\n# ---------------------------------------------------------------------------\n# 1. Generate Pydantic Models\n# ---------------------------------------------------------------------------\n\noutput_dir = Path(tempfile.mkdtemp(prefix=\"ninjastack-gen-\"))\nprint(f\"\ud83d\udcc1 Output directory: {output_dir}\\n\")\n\nmodel_paths = generate_models(SCHEMA.entities, output_dir)\nprint(\"\u2705 Generated Pydantic models:\")\nfor p in model_paths:\n    print(f\"   {p.relative_to(output_dir)}\")\n\n# Show one generated model\nbook_model = (output_dir / \"_generated\" / \"models\" / \"book.py\").read_text()\nprint(f\"\\n--- book.py (first 30 lines) ---\")\nfor line in book_model.splitlines()[:30]:\n    print(f\"  {line}\")\n\n# ---------------------------------------------------------------------------\n# 2. Generate ADK Agent Stubs\n# ---------------------------------------------------------------------------\n\nagent_paths = generate_agents(SCHEMA.entities, SCHEMA.domains, output_dir)\nprint(f\"\\n\u2705 Generated ADK agents:\")\nfor p in agent_paths:\n    print(f\"   {p.relative_to(output_dir)}\")\n\n# Show a data agent\nbook_agent = (output_dir / \"_generated\" / \"agents\" / \"book_agent.py\").read_text()\nprint(f\"\\n--- book_agent.py ---\")\nfor line in book_agent.splitlines():\n    print(f\"  {line}\")\n\n# Show a domain agent\ncatalog_agent = (output_dir / \"_generated\" / \"agents\" / \"catalog_agent.py\").read_text()\nprint(f\"\\n--- catalog_agent.py ---\")\nfor line in catalog_agent.splitlines():\n    print(f\"  {line}\")\n\n# ---------------------------------------------------------------------------\n# 3. Generate GraphQL Types\n# ---------------------------------------------------------------------------\n\ngql_paths = generate_graphql(SCHEMA.entities, output_dir)\nprint(f\"\\n\u2705 Generated GraphQL types:\")\nfor p in gql_paths:\n    print(f\"   {p.relative_to(output_dir)}\")\n\n# Show one GQL type\nbook_gql = (output_dir / \"_generated\" / \"graphql\" / \"book_gql.py\").read_text()\nprint(f\"\\n--- book_gql.py (first 40 lines) ---\")\nfor line in book_gql.splitlines()[:40]:\n    print(f\"  {line}\")\n\n# ---------------------------------------------------------------------------\n# Summary\n# ---------------------------------------------------------------------------\n\nall_files = list((output_dir / \"_generated\").rglob(\"*.py\"))\nprint(f\"\\n\ud83d\udcca Total generated files: {len(all_files)}\")\nprint(f\"   Models:  {len(model_paths)}\")\nprint(f\"   Agents:  {len(agent_paths)}\")\nprint(f\"   GraphQL: {len(gql_paths)}\")\nprint(f\"\\n\ud83d\udca1 These files are what `ninjastack sync` produces from your schema.json\")\n</code></pre>"},{"location":"examples/02-codegen/#run-it","title":"Run It","text":"<pre><code>PYTHONPATH=examples/bookstore uv run python examples/bookstore/02_code_generation.py\n</code></pre>"},{"location":"examples/03-data-agents/","title":"Example 3: Data Agents","text":"<p>Create and use deterministic CRUD agents \u2014 no LLM required.</p> examples/bookstore/03_data_agents.py<pre><code>#!/usr/bin/env python3\n\"\"\"Example 3: Data Agents \u2014 Deterministic CRUD agents (no LLM required).\n\nDemonstrates:\n- Creating a DataAgent for an entity (extends ADK BaseAgent)\n- Auto-generated CRUD + semantic search tools\n- Executing tools directly (deterministic, no LLM call)\n- Tool scoping \u2014 agents only see their own entity's tools\n- Tracing tool execution\n\"\"\"\n\nfrom ninja_agents.base import DataAgent\nfrom ninja_agents.tools import generate_crud_tools\nfrom ninja_agents.tracing import TraceContext\n\nfrom _bookstore_schema import BOOK, CUSTOMER, ORDER, REVIEW\n\n# ---------------------------------------------------------------------------\n# 1. Create Data Agents\n# ---------------------------------------------------------------------------\n\nbook_agent = DataAgent(entity=BOOK)\ncustomer_agent = DataAgent(entity=CUSTOMER)\norder_agent = DataAgent(entity=ORDER)\nreview_agent = DataAgent(entity=REVIEW)\n\nprint(\"\u2705 Data Agents created:\")\nfor agent in [book_agent, customer_agent, order_agent, review_agent]:\n    print(f\"   {agent.name} \u2014 tools: {agent.tool_names}\")\n    print(f\"     uses_llm: {agent.uses_llm}\")\n\n# ---------------------------------------------------------------------------\n# 2. Execute Tools Directly (No LLM)\n# ---------------------------------------------------------------------------\n\nprint(\"\\n--- Direct Tool Execution ---\")\n\n# Get a book by ID\nresult = book_agent.execute(\"book_get\", id=\"abc-123\")\nprint(f\"\\n\ud83d\udcd6 book_get(id='abc-123'):\")\nprint(f\"   {result}\")\n\n# List customers with a filter\nresult = customer_agent.execute(\"customer_list\", email_contains=\"@example.com\")\nprint(f\"\\n\ud83d\udc64 customer_list(email_contains='@example.com'):\")\nprint(f\"   {result}\")\n\n# Create an order\nresult = order_agent.execute(\n    \"order_create\",\n    customer_id=\"cust-456\",\n    total=29.99,\n    status=\"pending\",\n)\nprint(f\"\\n\ud83d\uded2 order_create(...):\")\nprint(f\"   {result}\")\n\n# Semantic search on reviews\nresult = review_agent.execute(\n    \"review_search_semantic\",\n    query=\"great character development and plot twists\",\n)\nprint(f\"\\n\ud83d\udd0d review_search_semantic(query='great character development...'):\")\nprint(f\"   {result}\")\n\n# ---------------------------------------------------------------------------\n# 3. Tool Scoping \u2014 Agents Can't Access Other Entity's Tools\n# ---------------------------------------------------------------------------\n\nprint(\"\\n--- Tool Scoping ---\")\n\ntry:\n    book_agent.execute(\"customer_get\", id=\"123\")\nexcept KeyError as e:\n    print(f\"\u2705 Scope enforced: {e}\")\n\n# ---------------------------------------------------------------------------\n# 4. Tracing\n# ---------------------------------------------------------------------------\n\nprint(\"\\n--- Tracing ---\")\n\ntrace = TraceContext()\nbook_agent.execute(\"book_list\", trace=trace, genre=\"sci-fi\")\norder_agent.execute(\"order_get\", trace=trace, id=\"ord-789\")\n\nprint(f\"   Trace spans: {len(trace.spans)}\")\nfor span in trace.spans:\n    print(f\"   [{span.agent_name}] tools called: {len(span.tool_calls)}, duration: {span.duration_ms:.1f}ms\")\n\n# ---------------------------------------------------------------------------\n# 5. Inspect Auto-Generated Tools\n# ---------------------------------------------------------------------------\n\nprint(\"\\n--- Auto-Generated Tool Details ---\")\n\ntools = generate_crud_tools(BOOK)\nfor tool in tools:\n    print(f\"   {tool.__name__}: {tool.__doc__}\")\n</code></pre>"},{"location":"examples/03-data-agents/#run-it","title":"Run It","text":"<pre><code>PYTHONPATH=examples/bookstore uv run python examples/bookstore/03_data_agents.py\n</code></pre>"},{"location":"examples/04-domain-agents/","title":"Example 4: Domain &amp; Coordinator Agents","text":"<p>Wire up the full agent hierarchy with LLM-powered orchestration.</p> examples/bookstore/04_domain_agents.py<pre><code>#!/usr/bin/env python3\n\"\"\"Example 4: Domain &amp; Coordinator Agents \u2014 LLM-powered orchestration.\n\nDemonstrates:\n- Creating DomainAgents that wrap DataAgent sub-agents\n- CoordinatorAgent for cross-domain routing\n- Delegation: domain agent \u2192 data agent tool execution\n- The full agent hierarchy: Coordinator \u2192 Domain \u2192 Data\n- How reasoning levels map to models\n\nNOTE: This example works without an API key \u2014 it exercises the agent wiring\nand delegation layer. Actual LLM calls require GOOGLE_API_KEY.\n\"\"\"\n\nfrom ninja_agents.base import CoordinatorAgent, DataAgent, DomainAgent\nfrom ninja_agents.tracing import TraceContext\nfrom ninja_core.schema.agent import ReasoningLevel\n\nfrom _bookstore_schema import (\n    BOOK, CUSTOMER, ORDER, REVIEW,\n    CATALOG_DOMAIN, COMMERCE_DOMAIN,\n)\n\n# ---------------------------------------------------------------------------\n# 1. Build the Agent Hierarchy\n# ---------------------------------------------------------------------------\n\n# Data agents (deterministic CRUD)\nbook_da = DataAgent(entity=BOOK)\nreview_da = DataAgent(entity=REVIEW)\ncustomer_da = DataAgent(entity=CUSTOMER)\norder_da = DataAgent(entity=ORDER)\n\n# Domain agents (LLM-powered, wrapping data agents)\ncatalog_agent = DomainAgent(\n    domain=CATALOG_DOMAIN,\n    data_agents=[book_da, review_da],\n)\ncommerce_agent = DomainAgent(\n    domain=COMMERCE_DOMAIN,\n    data_agents=[customer_da, order_da],\n)\n\n# Coordinator (top-level router)\ncoordinator = CoordinatorAgent(\n    domain_agents=[catalog_agent, commerce_agent],\n)\n\nprint(\"\u2705 Agent Hierarchy:\")\nprint(f\"   Coordinator: {coordinator.name}\")\nprint(f\"     \u251c\u2500\u2500 {catalog_agent.name} (model: {catalog_agent.agent.model})\")\nprint(f\"     \u2502   \u251c\u2500\u2500 {book_da.name}\")\nprint(f\"     \u2502   \u2514\u2500\u2500 {review_da.name}\")\nprint(f\"     \u2514\u2500\u2500 {commerce_agent.name} (model: {commerce_agent.agent.model})\")\nprint(f\"         \u251c\u2500\u2500 {customer_da.name}\")\nprint(f\"         \u2514\u2500\u2500 {order_da.name}\")\n\n# ---------------------------------------------------------------------------\n# 2. Domain Agent Delegation\n# ---------------------------------------------------------------------------\n\nprint(\"\\n--- Domain Agent Delegation ---\")\n\n# The domain agent delegates to its data agents\ntrace = TraceContext()\n\n# Catalog domain: get a book\nresult = catalog_agent.delegate(\"Book\", \"book_get\", trace=trace, id=\"book-001\")\nprint(f\"\\n\ud83d\udcd6 catalog.delegate('Book', 'book_get'):\")\nprint(f\"   {result}\")\n\n# Catalog domain: search reviews semantically\nresult = catalog_agent.delegate(\"Review\", \"review_search_semantic\", trace=trace, query=\"mind-bending sci-fi\")\nprint(f\"\\n\ud83d\udd0d catalog.delegate('Review', 'review_search_semantic'):\")\nprint(f\"   {result}\")\n\n# Commerce domain: create an order\nresult = commerce_agent.delegate(\"Order\", \"order_create\", trace=trace,\n                                  customer_id=\"cust-001\", total=42.50, status=\"pending\")\nprint(f\"\\n\ud83d\uded2 commerce.delegate('Order', 'order_create'):\")\nprint(f\"   {result}\")\n\n# ---------------------------------------------------------------------------\n# 3. Cross-Domain Routing via Coordinator\n# ---------------------------------------------------------------------------\n\nprint(\"\\n--- Coordinator Routing ---\")\n\n# Route a request to specific domains\nresults = coordinator.route(\n    request=\"Show me sci-fi books and the customer's order history\",\n    target_domains=[\"Catalog\", \"Commerce\"],\n    trace=trace,\n)\n\nprint(f\"\\n\ud83c\udfaf coordinator.route(target_domains=['Catalog', 'Commerce']):\")\nfor domain_name, result in results.items():\n    print(f\"   {domain_name}: {result}\")\n\n# ---------------------------------------------------------------------------\n# 4. Scope Enforcement\n# ---------------------------------------------------------------------------\n\nprint(\"\\n--- Scope Enforcement ---\")\n\n# Domain agents only know about their own entities\ntry:\n    catalog_agent.delegate(\"Order\", \"order_get\", id=\"123\")\nexcept KeyError as e:\n    print(f\"\u2705 Catalog can't access Order: {e}\")\n\ntry:\n    coordinator.route(\"test\", target_domains=[\"Shipping\"])\nexcept Exception:\n    print(\"\u2705 Coordinator rejects unknown domains\")\n\n# Check the routing result\nresult = coordinator.route(\"test\", target_domains=[\"Shipping\"])\nif \"Shipping\" in result and \"error\" in result[\"Shipping\"]:\n    print(f\"   \u2192 {result['Shipping']}\")\n\n# ---------------------------------------------------------------------------\n# 5. Reasoning Level \u2192 Model Mapping\n# ---------------------------------------------------------------------------\n\nprint(\"\\n--- Reasoning Levels ---\")\n\nlevels = {\n    ReasoningLevel.NONE: \"No LLM (deterministic only)\",\n    ReasoningLevel.LOW: \"gemini-2.0-flash\",\n    ReasoningLevel.MEDIUM: \"gemini-2.5-flash\",\n    ReasoningLevel.HIGH: \"gemini-2.5-pro\",\n}\n\nfor level, desc in levels.items():\n    print(f\"   {level.value:8s} \u2192 {desc}\")\n\nprint(f\"\\n   Catalog agent reasoning:  {catalog_agent.config.reasoning_level.value} \u2192 {catalog_agent.agent.model}\")\nprint(f\"   Commerce agent reasoning: {commerce_agent.config.reasoning_level.value} \u2192 {commerce_agent.agent.model}\")\n\n# ---------------------------------------------------------------------------\n# 6. Trace Summary\n# ---------------------------------------------------------------------------\n\nprint(f\"\\n--- Trace Summary ({len(trace.spans)} spans) ---\")\nfor span in trace.spans:\n    print(f\"   [{span.agent_name}] {len(span.tool_calls)} tool calls, {span.duration_ms:.1f}ms\")\n</code></pre>"},{"location":"examples/04-domain-agents/#run-it","title":"Run It","text":"<pre><code>PYTHONPATH=examples/bookstore uv run python examples/bookstore/04_domain_agents.py\n</code></pre>"},{"location":"examples/05-auth-rbac/","title":"Example 5: Auth &amp; RBAC","text":"<p>Protect agents with authentication and role-based permissions.</p> examples/bookstore/05_auth_rbac.py<pre><code>#!/usr/bin/env python3\n\"\"\"Example 5: Auth &amp; RBAC \u2014 Protect agents with authentication and permissions.\n\nDemonstrates:\n- Built-in identity: user registration, login, JWT tokens\n- RBAC policy with string-based permissions (action:scope)\n- Permission checking at domain/entity level\n- Protecting agent tool execution with role checks\n\nPermission format: \"action:scope\"\n  - read:Catalog         \u2014 read any entity in Catalog domain\n  - write:Catalog.Review \u2014 write only Review entity in Catalog\n  - delete:*             \u2014 delete anything\n  - *:*                  \u2014 superuser\n\"\"\"\n\nfrom ninja_auth.config import IdentityConfig\nfrom ninja_auth.context import UserContext\nfrom ninja_auth.rbac import RBACConfig, RBACPolicy, RoleDefinition\nfrom ninja_auth.strategies.identity import IdentityStrategy\n\n# ---------------------------------------------------------------------------\n# 1. Built-in Identity (Registration + Login + Tokens)\n# ---------------------------------------------------------------------------\n\nJWT_SECRET = \"bookstore-example-secret-key-32bytes!\"\nidentity_config = IdentityConfig(token_secret=JWT_SECRET)\nidentity = IdentityStrategy(config=identity_config)\n\nprint(\"--- User Registration &amp; Login ---\")\n\n# Register users (returns UserContext)\nadmin_ctx = identity.register(email=\"admin@bookstore.com\", password=\"s3cur3!\", roles=[\"admin\"])\neditor_ctx = identity.register(email=\"editor@bookstore.com\", password=\"wr1t3r!\", roles=[\"editor\"])\ncustomer_ctx = identity.register(email=\"alice@example.com\", password=\"r3ad3r!\", roles=[\"customer\"])\n\nprint(f\"  Registered: {admin_ctx.email} (roles={admin_ctx.roles})\")\nprint(f\"  Registered: {editor_ctx.email} (roles={editor_ctx.roles})\")\nprint(f\"  Registered: {customer_ctx.email} (roles={customer_ctx.roles})\")\n\n# Issue JWT tokens\nadmin_token = identity.issue_token(admin_ctx)\ncustomer_token = identity.issue_token(customer_ctx)\nprint(f\"\\n  Admin JWT:    {admin_token[:50]}...\")\nprint(f\"  Customer JWT: {customer_token[:50]}...\")\n\n# Validate token \u2192 get context back\nvalidated = identity.validate_token(admin_token)\nprint(f\"\\n  Validated: user_id={validated.user_id}, roles={validated.roles}\")\n\n# Login flow\nlogged_in = identity.login(email=\"alice@example.com\", password=\"r3ad3r!\")\nprint(f\"  Login OK:  user_id={logged_in.user_id}, email={logged_in.email}\")\n\nbad_login = identity.login(email=\"alice@example.com\", password=\"wrong!\")\nprint(f\"  Bad login: {bad_login}\")  # None\n\n# ---------------------------------------------------------------------------\n# 2. RBAC Policy\n# ---------------------------------------------------------------------------\n\nprint(\"\\n--- RBAC Policy ---\")\n\n# Built-in roles (from ninja_auth.rbac):\n#   admin  \u2192 *:*\n#   editor \u2192 read:*, write:*\n#   viewer \u2192 read:*\n#\n# We add a custom \"customer\" role with scoped permissions:\nrbac_config = RBACConfig(\n    enabled=True,\n    roles={\n        \"customer\": RoleDefinition(\n            permissions=[\n                \"read:Catalog\",             # Read all Catalog entities (Book, Review)\n                \"write:Catalog.Review\",     # Write reviews only\n                \"read:Commerce.Order\",      # Read own orders\n                \"read:Commerce.Customer\",   # Read own profile\n            ],\n            description=\"Registered bookstore customer\",\n        ),\n    },\n)\n\npolicy = RBACPolicy(config=rbac_config)\n\nprint(f\"  Known roles: {policy.roles()}\")\nprint(f\"  Admin perms:    {policy.permissions_for_roles(['admin'])}\")\nprint(f\"  Editor perms:   {policy.permissions_for_roles(['editor'])}\")\nprint(f\"  Customer perms: {policy.permissions_for_roles(['customer'])}\")\n\n# ---------------------------------------------------------------------------\n# 3. Permission Checks\n# ---------------------------------------------------------------------------\n\nprint(\"\\n--- Permission Checks ---\")\n\n\ndef can(roles: list[str], action: str, domain: str, entity: str | None = None) -&gt; bool:\n    perms = policy.permissions_for_roles(roles)\n    return policy.is_allowed(perms, action, domain, entity)\n\n\n# Admin \u2014 full access via *:*\nprint(f\"  Admin delete Book?       {can(['admin'], 'delete', 'Catalog', 'Book')}\")      # True\nprint(f\"  Admin write Order?       {can(['admin'], 'write', 'Commerce', 'Order')}\")      # True\n\n# Editor \u2014 built-in read:* + write:*, but no delete\nprint(f\"  Editor write Book?       {can(['editor'], 'write', 'Catalog', 'Book')}\")       # True\nprint(f\"  Editor delete Book?      {can(['editor'], 'delete', 'Catalog', 'Book')}\")      # False\n\n# Customer \u2014 custom scoped permissions\nprint(f\"  Customer read Book?      {can(['customer'], 'read', 'Catalog', 'Book')}\")      # True\nprint(f\"  Customer write Review?   {can(['customer'], 'write', 'Catalog', 'Review')}\")   # True\nprint(f\"  Customer write Book?     {can(['customer'], 'write', 'Catalog', 'Book')}\")     # False\nprint(f\"  Customer read Order?     {can(['customer'], 'read', 'Commerce', 'Order')}\")    # True\nprint(f\"  Customer write Order?    {can(['customer'], 'write', 'Commerce', 'Order')}\")   # False\nprint(f\"  Customer delete Review?  {can(['customer'], 'delete', 'Catalog', 'Review')}\")  # False\n\n# ---------------------------------------------------------------------------\n# 4. Enforcement (raises PermissionError)\n# ---------------------------------------------------------------------------\n\nprint(\"\\n--- Enforcement ---\")\n\nadmin_perms = policy.permissions_for_roles([\"admin\"])\ncustomer_perms = policy.permissions_for_roles([\"customer\"])\n\ntry:\n    policy.check(admin_perms, \"delete\", \"Catalog\", \"Book\")\n    print(\"  \u2705 Admin delete Book: ALLOWED\")\nexcept PermissionError as e:\n    print(f\"  \ud83d\udeab {e}\")\n\ntry:\n    policy.check(customer_perms, \"write\", \"Commerce\", \"Order\")\n    print(\"  \u2705 Customer write Order: ALLOWED\")\nexcept PermissionError as e:\n    print(f\"  \ud83d\udeab Customer write Order: {e}\")\n\ntry:\n    policy.check(customer_perms, \"delete\", \"Catalog\", \"Review\")\n    print(\"  \u2705 Customer delete Review: ALLOWED\")\nexcept PermissionError as e:\n    print(f\"  \ud83d\udeab Customer delete Review: {e}\")\n\n# ---------------------------------------------------------------------------\n# 5. Protecting Agent Tool Execution\n# ---------------------------------------------------------------------------\n\nprint(\"\\n--- Protected Agent Execution ---\")\n\nfrom ninja_agents.base import DataAgent\nfrom _bookstore_schema import BOOK, REVIEW\n\nbook_agent = DataAgent(entity=BOOK)\nreview_agent = DataAgent(entity=REVIEW)\n\n\ndef protected_execute(agent, tool_name, user_roles, domain, **kwargs):\n    \"\"\"Execute a tool only if the user's roles grant permission.\"\"\"\n    if tool_name.endswith((\"_get\", \"_list\", \"_search_semantic\")):\n        action = \"read\"\n    elif tool_name.endswith(\"_delete\"):\n        action = \"delete\"\n    else:\n        action = \"write\"\n\n    perms = policy.permissions_for_roles(user_roles)\n    if not policy.is_allowed(perms, action, domain, agent.entity.name):\n        return f\"\ud83d\udeab DENIED: {user_roles} cannot {action} {domain}.{agent.entity.name}\"\n\n    result = agent.execute(tool_name, **kwargs)\n    return f\"\u2705 {result}\"\n\n\nprint(f\"  {protected_execute(book_agent, 'book_list', ['customer'], 'Catalog', genre='sci-fi')}\")\nprint(f\"  {protected_execute(review_agent, 'review_create', ['customer'], 'Catalog', book_id='b1', rating=5)}\")\nprint(f\"  {protected_execute(book_agent, 'book_create', ['customer'], 'Catalog', title='Hacked')}\")\nprint(f\"  {protected_execute(review_agent, 'review_delete', ['customer'], 'Catalog', id='r1')}\")\nprint(f\"  {protected_execute(book_agent, 'book_delete', ['admin'], 'Catalog', id='b-old')}\")\n\nprint(\"\\n\ud83d\udca1 In production, the gateway middleware resolves JWT \u2192 roles \u2192 permissions\")\nprint(\"   and injects them into the request context before agents execute.\")\n</code></pre>"},{"location":"examples/05-auth-rbac/#run-it","title":"Run It","text":"<pre><code>PYTHONPATH=examples/bookstore uv run python examples/bookstore/05_auth_rbac.py\n</code></pre>"},{"location":"examples/06-end-to-end/","title":"Example 6: End-to-End","text":"<p>Full pipeline from schema definition to authenticated agent queries.</p> examples/bookstore/06_end_to_end.py<pre><code>#!/usr/bin/env python3\n\"\"\"Example 6: End-to-End \u2014 Full pipeline from schema to authenticated agent query.\n\nDemonstrates the complete NinjaStack flow:\n1. Define schema (ASD)\n2. Generate code (models, agents, GraphQL)\n3. Wire up agent hierarchy (Data \u2192 Domain \u2192 Coordinator)\n4. Apply auth + RBAC\n5. Process an authenticated request through the full stack\n\nNo API key required \u2014 runs entirely locally with deterministic agents.\n\"\"\"\n\nimport tempfile\nfrom pathlib import Path\n\nfrom ninja_agents.base import CoordinatorAgent, DataAgent, DomainAgent\nfrom ninja_agents.tracing import TraceContext\nfrom ninja_auth.context import UserContext\nfrom ninja_auth.rbac import RBACConfig, RBACPolicy, RoleDefinition\nfrom ninja_codegen.generators.agents import generate_agents\nfrom ninja_codegen.generators.graphql import generate_graphql\nfrom ninja_codegen.generators.models import generate_models\nfrom ninja_core.serialization.io import save_schema\n\nfrom _bookstore_schema import (\n    SCHEMA, ENTITIES, DOMAINS,\n    BOOK, CUSTOMER, ORDER, REVIEW,\n    CATALOG_DOMAIN, COMMERCE_DOMAIN,\n)\n\nprint(\"=\" * 60)\nprint(\"  NinjaStack End-to-End: Online Bookstore\")\nprint(\"=\" * 60)\n\n# ---------------------------------------------------------------------------\n# Step 1: Schema \u2192 Disk\n# ---------------------------------------------------------------------------\n\nschema_dir = Path(tempfile.mkdtemp(prefix=\"ninjastack-e2e-\"))\nschema_path = schema_dir / \".ninjastack\" / \"schema.json\"\nsave_schema(SCHEMA, schema_path)\nprint(f\"\\n\u2705 Step 1: Schema saved to {schema_path}\")\nprint(f\"   {len(ENTITIES)} entities, {len(SCHEMA.relationships)} relationships, {len(DOMAINS)} domains\")\n\n# ---------------------------------------------------------------------------\n# Step 2: Code Generation\n# ---------------------------------------------------------------------------\n\noutput_dir = schema_dir / \"generated\"\nmodel_paths = generate_models(ENTITIES, output_dir)\nagent_paths = generate_agents(ENTITIES, DOMAINS, output_dir)\ngql_paths = generate_graphql(ENTITIES, output_dir)\n\ntotal = len(model_paths) + len(agent_paths) + len(gql_paths)\nprint(f\"\\n\u2705 Step 2: Generated {total} files\")\nprint(f\"   {len(model_paths)} models, {len(agent_paths)} agents, {len(gql_paths)} GraphQL types\")\n\n# ---------------------------------------------------------------------------\n# Step 3: Wire Agent Hierarchy\n# ---------------------------------------------------------------------------\n\n# Data agents\nbook_da = DataAgent(entity=BOOK)\nreview_da = DataAgent(entity=REVIEW)\ncustomer_da = DataAgent(entity=CUSTOMER)\norder_da = DataAgent(entity=ORDER)\n\n# Domain agents\ncatalog = DomainAgent(domain=CATALOG_DOMAIN, data_agents=[book_da, review_da])\ncommerce = DomainAgent(domain=COMMERCE_DOMAIN, data_agents=[customer_da, order_da])\n\n# Coordinator\ncoordinator = CoordinatorAgent(domain_agents=[catalog, commerce])\n\nprint(f\"\\n\u2705 Step 3: Agent hierarchy wired\")\nprint(f\"   Coordinator \u2192 {coordinator.domain_names}\")\n\n# ---------------------------------------------------------------------------\n# Step 4: Auth + RBAC\n# ---------------------------------------------------------------------------\n\nrbac_config = RBACConfig(\n    enabled=True,\n    roles={\n        \"customer\": RoleDefinition(permissions=[\n            \"read:Catalog\", \"write:Catalog.Review\",\n            \"read:Commerce.Order\", \"read:Commerce.Customer\",\n        ]),\n    },\n)\npolicy = RBACPolicy(config=rbac_config)\n\nadmin = UserContext(user_id=\"admin-1\", roles=[\"admin\"])\ncustomer_user = UserContext(user_id=\"customer-42\", roles=[\"customer\"])\n\nprint(f\"\\n\u2705 Step 4: RBAC configured\")\nprint(f\"   Admin:    full access\")\nprint(f\"   Customer: read catalog, read/write reviews, read own orders\")\n\n# ---------------------------------------------------------------------------\n# Step 5: Process Requests\n# ---------------------------------------------------------------------------\n\nprint(f\"\\n{'=' * 60}\")\nprint(\"  Simulated Request Processing\")\nprint(f\"{'=' * 60}\")\n\ntrace = TraceContext()\n\n\ndef process_request(user: UserContext, domain_name: str, entity_name: str,\n                    tool_name: str, **kwargs):\n    \"\"\"Simulate a full authenticated request through the stack.\"\"\"\n    # 1. Determine action from tool name\n    if tool_name.endswith((\"_get\", \"_list\", \"_search_semantic\")):\n        action = \"read\"\n    elif tool_name.endswith(\"_delete\"):\n        action = \"delete\"\n    else:\n        action = \"write\"\n\n    # 2. RBAC check\n    perms = policy.permissions_for_roles(user.roles)\n    if not policy.is_allowed(perms, action, domain_name, entity_name):\n        return {\"status\": \"DENIED\", \"user\": user.user_id, \"action\": action, \"entity\": entity_name}\n\n    # 3. Route through coordinator \u2192 domain \u2192 data agent\n    domain_agent = coordinator.get_domain_agent(domain_name)\n    if domain_agent is None:\n        return {\"status\": \"NOT_FOUND\", \"domain\": domain_name}\n\n    result = domain_agent.delegate(entity_name, tool_name, trace=trace, **kwargs)\n    return {\"status\": \"OK\", \"user\": user.user_id, \"result\": result}\n\n\n# --- Customer browses books ---\nprint(\"\\n\ud83d\udcd6 Customer browses books:\")\nr = process_request(customer_user, \"Catalog\", \"Book\", \"book_list\", genre=\"sci-fi\")\nprint(f\"   {r}\")\n\n# --- Customer searches reviews ---\nprint(\"\\n\ud83d\udd0d Customer searches reviews:\")\nr = process_request(customer_user, \"Catalog\", \"Review\", \"review_search_semantic\",\n                    query=\"best mystery novels this year\")\nprint(f\"   {r}\")\n\n# --- Customer writes a review ---\nprint(\"\\n\u270d\ufe0f  Customer writes a review:\")\nr = process_request(customer_user, \"Catalog\", \"Review\", \"review_create\",\n                    book_id=\"book-001\", rating=5, text=\"Absolutely loved it!\")\nprint(f\"   {r}\")\n\n# --- Customer tries to delete a book (DENIED) ---\nprint(\"\\n\ud83d\udeab Customer tries to delete a book:\")\nr = process_request(customer_user, \"Catalog\", \"Book\", \"book_delete\", id=\"book-001\")\nprint(f\"   {r}\")\n\n# --- Customer tries to create an order (DENIED - write on Order) ---\nprint(\"\\n\ud83d\udeab Customer tries to create an order:\")\nr = process_request(customer_user, \"Commerce\", \"Order\", \"order_create\",\n                    customer_id=\"customer-42\", total=29.99)\nprint(f\"   {r}\")\n\n# --- Admin creates an order (OK) ---\nprint(\"\\n\u2705 Admin creates an order:\")\nr = process_request(admin, \"Commerce\", \"Order\", \"order_create\",\n                    customer_id=\"customer-42\", total=29.99)\nprint(f\"   {r}\")\n\n# --- Admin deletes a book (OK) ---\nprint(\"\\n\u2705 Admin deletes a book:\")\nr = process_request(admin, \"Catalog\", \"Book\", \"book_delete\", id=\"book-obsolete\")\nprint(f\"   {r}\")\n\n# ---------------------------------------------------------------------------\n# Summary\n# ---------------------------------------------------------------------------\n\nprint(f\"\\n{'=' * 60}\")\nprint(\"  Summary\")\nprint(f\"{'=' * 60}\")\nprint(f\"  Schema:    {len(ENTITIES)} entities, {len(SCHEMA.relationships)} relationships\")\nprint(f\"  Generated: {total} files (models + agents + GraphQL)\")\nprint(f\"  Agents:    {len(coordinator.domain_names)} domains, 4 data agents\")\nprint(f\"  Auth:      {len(policy.roles())} roles, RBAC enforced\")\nprint(f\"  Trace:     {len(trace.spans)} spans recorded\")\nprint(f\"\\n\ud83d\udca1 Add GOOGLE_API_KEY to enable real LLM-powered agent conversations.\")\nprint(f\"   The coordinator will use Gemini to classify intent and delegate.\")\n</code></pre>"},{"location":"examples/06-end-to-end/#run-it","title":"Run It","text":"<pre><code>PYTHONPATH=examples/bookstore uv run python examples/bookstore/06_end_to_end.py\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Learn how to install NinjaStack and build your first agentic backend.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12+</li> <li>uv package manager</li> <li>A database to introspect (optional \u2014 you can use conversational mode)</li> </ul>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ol> <li>Installation \u2014 Set up NinjaStack</li> <li>Quickstart \u2014 Build a bookstore backend in 5 minutes</li> <li>Concepts \u2014 Understand the core ideas</li> </ol>"},{"location":"getting-started/concepts/","title":"Core Concepts","text":""},{"location":"getting-started/concepts/#agentic-schema-definition-asd","title":"Agentic Schema Definition (ASD)","text":"<p>The ASD is NinjaStack's single source of truth. It's a typed, composable schema that describes:</p> <ul> <li>Entities \u2014 Your data models (tables, collections, nodes)</li> <li>Fields \u2014 Typed columns with constraints, indexes, and embedding configs</li> <li>Relationships \u2014 Hard (FK), soft (semantic), and graph edges between entities</li> <li>Domains \u2014 Logical groupings of entities under one expert agent</li> <li>Agent Configs \u2014 Model, reasoning level, temperature per domain</li> </ul> <pre><code>erDiagram\n    AgenticSchema ||--o{ EntitySchema : contains\n    AgenticSchema ||--o{ RelationshipSchema : contains\n    AgenticSchema ||--o{ DomainSchema : contains\n    DomainSchema ||--|| AgentConfig : has\n    EntitySchema ||--o{ FieldSchema : has\n    FieldSchema ||--o| EmbeddingConfig : may_have\n    FieldSchema ||--o| FieldConstraint : may_have</code></pre>"},{"location":"getting-started/concepts/#agent-hierarchy","title":"Agent Hierarchy","text":"<p>NinjaStack organizes agents in a three-tier hierarchy:</p>"},{"location":"getting-started/concepts/#data-agents","title":"Data Agents","text":"<ul> <li>Extend ADK <code>BaseAgent</code></li> <li>Deterministic \u2014 no LLM calls</li> <li>Own one entity, scoped CRUD tools</li> <li>Fast, predictable, testable</li> </ul>"},{"location":"getting-started/concepts/#domain-agents","title":"Domain Agents","text":"<ul> <li>Wrap ADK <code>LlmAgent</code></li> <li>LLM-powered \u2014 use Gemini for reasoning</li> <li>Own one business domain (group of entities)</li> <li>Delegate to data agents for execution</li> <li>Configurable reasoning level (none \u2192 low \u2192 medium \u2192 high)</li> </ul>"},{"location":"getting-started/concepts/#coordinator-agent","title":"Coordinator Agent","text":"<ul> <li>Top-level ADK <code>LlmAgent</code></li> <li>Routes requests to the right domain</li> <li>Synthesizes cross-domain results</li> <li>Intent classification via LLM</li> </ul>"},{"location":"getting-started/concepts/#reasoning-levels","title":"Reasoning Levels","text":"Level Model Use Case <code>NONE</code> \u2014 Deterministic only (data agents) <code>LOW</code> gemini-2.0-flash Simple completions <code>MEDIUM</code> gemini-2.5-flash Multi-step reasoning <code>HIGH</code> gemini-2.5-pro Full chain-of-thought"},{"location":"getting-started/concepts/#tool-scoping","title":"Tool Scoping","text":"<p>Every agent only sees its own tools. A Book data agent cannot call Customer tools. A Catalog domain agent cannot access Commerce entities. The coordinator routes across domains but never executes tools directly.</p> <p>This prevents tool leaking, reduces hallucination surface, and enforces clear ownership boundaries.</p>"},{"location":"getting-started/concepts/#storage-engines","title":"Storage Engines","text":"<p>Entities declare their storage engine:</p> Engine Backend Use Case <code>SQL</code> PostgreSQL, SQLite Structured relational data <code>MONGO</code> MongoDB Document-oriented data <code>GRAPH</code> Neo4j Connected/relationship-heavy data <code>VECTOR</code> ChromaDB, Pinecone Semantic search, embeddings <p>The unified persistence layer handles routing to the correct backend.</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#from-pypi","title":"From PyPI","text":"<pre><code>pip install agentic-backend\n</code></pre>"},{"location":"getting-started/installation/#from-source","title":"From Source","text":"<pre><code>git clone https://github.com/codeninja/agentic-backend.git\ncd agentic-backend\nuv sync\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<pre><code>ninjastack --version\n</code></pre>"},{"location":"getting-started/installation/#optional-api-key-for-llm-features","title":"Optional: API Key for LLM Features","text":"<p>The conversational setup assistant and domain agents require a Gemini API key:</p> <pre><code>export GOOGLE_API_KEY=\"your-key-here\"\n</code></pre> <p>Note</p> <p>Data agents, code generation, and RBAC work without an API key. Only LLM-powered features (domain agents, setup assistant) need one.</p>"},{"location":"getting-started/installation/#development-setup","title":"Development Setup","text":"<pre><code># Clone and install all workspace packages\ngit clone https://github.com/codeninja/agentic-backend.git\ncd agentic-backend\nuv sync\n\n# Run tests\nuv run pytest\n\n# Run a specific library's tests\nuv run pytest libs/ninja-core/\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":"<p>Build a bookstore agentic backend in under 5 minutes.</p>"},{"location":"getting-started/quickstart/#option-a-bolt-on-to-an-existing-database","title":"Option A: Bolt-on to an Existing Database","text":"<pre><code># Introspect your database\nninjastack introspect --db postgres://localhost/bookstore\n\n# Review the discovered schema\ncat .ninjastack/schema.json\n\n# Generate the full stack\nninjastack sync\n\n# Start the server\nninjastack serve\n</code></pre>"},{"location":"getting-started/quickstart/#option-b-design-from-scratch","title":"Option B: Design from Scratch","text":"<pre><code>from ninja_core.schema.entity import EntitySchema, FieldSchema, FieldType, StorageEngine\nfrom ninja_core.schema.domain import DomainSchema\nfrom ninja_core.schema.project import AgenticSchema\n\n# Define an entity\nbook = EntitySchema(\n    name=\"Book\",\n    storage_engine=StorageEngine.SQL,\n    fields=[\n        FieldSchema(name=\"id\", field_type=FieldType.UUID, primary_key=True),\n        FieldSchema(name=\"title\", field_type=FieldType.STRING, indexed=True),\n        FieldSchema(name=\"author\", field_type=FieldType.STRING),\n        FieldSchema(name=\"price\", field_type=FieldType.FLOAT),\n    ],\n)\n\n# Group into a domain\ncatalog = DomainSchema(name=\"Catalog\", entities=[\"Book\"])\n\n# Create the project schema\nschema = AgenticSchema(\n    project_name=\"Bookstore\",\n    entities=[book],\n    domains=[catalog],\n)\n</code></pre>"},{"location":"getting-started/quickstart/#option-c-conversational-setup","title":"Option C: Conversational Setup","text":"<pre><code>ninjastack init --interactive\n\n# Chat with the AI assistant:\n# \"I need a bookstore with books, customers, orders, and reviews.\n#  Reviews should support semantic search.\"\n</code></pre>"},{"location":"getting-started/quickstart/#what-gets-generated","title":"What Gets Generated","text":"<p>After <code>ninjastack sync</code>, you get:</p> Generated Description <code>_generated/models/</code> Pydantic models per entity <code>_generated/agents/</code> ADK DataAgent + DomainAgent + CoordinatorAgent <code>_generated/graphql/</code> Strawberry types, queries, mutations <code>.ninjastack/schema.json</code> Your Agentic Schema Definition"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Concepts \u2014 Understand the architecture</li> <li>Examples \u2014 Walk through the full bookstore example</li> </ul>"}]}